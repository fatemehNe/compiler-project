Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    NUMERROR
    TOKENERROR
    WHITESPACE

Grammar

Rule 0     S' -> program
Rule 1     program -> macros classes
Rule 2     macros -> macros macro
Rule 3     macros -> <empty>
Rule 4     macro -> reference
Rule 5     reference -> REFERENCE STRING
Rule 6     classes -> classes class
Rule 7     classes -> <empty>
Rule 8     class -> CLASS ID LCB symbol_decs RCB
Rule 9     symbol_decs -> symbol_decs symbol_dec
Rule 10    symbol_decs -> <empty>
Rule 11    symbol_dec -> var_dec
Rule 12    symbol_dec -> func_dec
Rule 13    var_dec -> var_type var_list SEMICOLON
Rule 14    var_type -> return_type
Rule 15    var_type -> lvalue1
Rule 16    var_type -> STATIC return_type
Rule 17    var_type -> STATIC lvalue1
Rule 18    return_type -> INT_TYPE
Rule 19    return_type -> REAL_TYPE
Rule 20    return_type -> BOOL_TYPE
Rule 21    return_type -> STRING_TYPE
Rule 22    var_list -> var_list COMMA var_list_item
Rule 23    var_list -> var_list_item
Rule 24    item1 -> ID ASSIGNMENT exp
Rule 25    var_list_item -> item1
Rule 26    var_list_item -> ID
Rule 27    func_dec -> var_type func_body
Rule 28    func_dec -> VOID func_body
Rule 29    func_dec -> STATIC VOID func_body
Rule 30    func_body -> ID LP formal_arguments RP block
Rule 31    formal_arguments -> formal_arguments_list
Rule 32    formal_arguments -> <empty>
Rule 33    formal_arguments_list -> formal_arguments_list COMMA formal_argument
Rule 34    formal_arguments_list -> formal_argument
Rule 35    formal_argument -> return_type ID
Rule 36    formal_argument -> lvalue1 ID
Rule 37    block -> LCB statements_list RCB
Rule 38    block -> statement
Rule 39    statements_list -> statements_list statement
Rule 40    statements_list -> <empty>
Rule 41    statement -> SEMICOLON
Rule 42    statement -> exp SEMICOLON
Rule 43    statement -> assignment
Rule 44    statement -> print
Rule 45    statement -> statement_var_dec
Rule 46    statement -> if
Rule 47    statement -> for
Rule 48    statement -> while
Rule 49    statement -> return
Rule 50    statement -> break
Rule 51    statement -> continue
Rule 52    assignment -> lvalue ASSIGNMENT exp SEMICOLON
Rule 53    lvalue -> lvalue1
Rule 54    lvalue -> lvalue2
Rule 55    lvalue2 -> ID DOT ID
Rule 56    lvalue1 -> ID
Rule 57    print -> PRINT LP STRING RP SEMICOLON
Rule 58    statement_var_dec -> return_type var_list SEMICOLON
Rule 59    statement_var_dec -> lvalue1 var_list SEMICOLON
Rule 60    if -> IF LP exp RP block elseif_blocks else_block
Rule 61    elseif_blocks -> elseifs
Rule 62    elseif_blocks -> <empty>
Rule 63    elseifs -> elseifs elseif
Rule 64    elseifs -> elseif
Rule 65    elseif -> ELSEIF LP exp RP block
Rule 66    else_block -> ELSE block
Rule 67    else_block -> <empty>
Rule 68    for -> FOR LP ID IN exp TO exp STEPS exp RP block
Rule 69    while -> WHILE LP exp RP block
Rule 70    return -> RETURN exp SEMICOLON
Rule 71    break -> BREAK SEMICOLON
Rule 72    continue -> CONTINUE SEMICOLON
Rule 73    exp -> INTEGER
Rule 74    exp -> REAL
Rule 75    exp -> TRUE
Rule 76    exp -> FALSE
Rule 77    exp -> STRING
Rule 78    exp -> lvalue
Rule 79    exp -> binary_operation
Rule 80    exp -> logical_operation
Rule 81    exp -> comparison_operation
Rule 82    exp -> bitwise_operation
Rule 83    exp -> unary_operation
Rule 84    exp -> LP exp RP
Rule 85    exp -> function_call
Rule 86    binary_operation -> exp ADDITION exp
Rule 87    binary_operation -> exp SUBTRACTION exp
Rule 88    binary_operation -> exp MULTIPLICATION exp
Rule 89    binary_operation -> exp DIVISION exp
Rule 90    binary_operation -> exp MODULO exp
Rule 91    binary_operation -> exp POWER exp
Rule 92    binary_operation -> exp SHIFT_LEFT exp
Rule 93    binary_operation -> exp SHIFT_RIGHT exp
Rule 94    logical_operation -> exp AND exp
Rule 95    logical_operation -> exp OR exp
Rule 96    comparison_operation -> exp LT exp
Rule 97    comparison_operation -> exp LE exp
Rule 98    comparison_operation -> exp GT exp
Rule 99    comparison_operation -> exp GE exp
Rule 100   comparison_operation -> exp EQ exp
Rule 101   comparison_operation -> exp NE exp
Rule 102   bitwise_operation -> exp BITWISE_AND exp
Rule 103   bitwise_operation -> exp BITWISE_OR exp
Rule 104   unary_operation -> SUBTRACTION exp
Rule 105   unary_operation -> NOT exp
Rule 106   unary_operation -> BITWISE_NOT exp
Rule 107   function_call -> lvalue2 function_call_body
Rule 108   function_call -> lvalue1 function_call_body
Rule 109   function_call_body -> LP actual_arguments RP
Rule 110   actual_arguments -> actual_arguments_list
Rule 111   actual_arguments -> <empty>
Rule 112   actual_arguments_list -> actual_arguments_list COMMA exp
Rule 113   actual_arguments_list -> exp

Terminals, with rules where they appear

ADDITION             : 86
AND                  : 94
ASSIGNMENT           : 24 52
BITWISE_AND          : 102
BITWISE_NOT          : 106
BITWISE_OR           : 103
BOOL_TYPE            : 20
BREAK                : 71
CLASS                : 8
COMMA                : 22 33 112
COMMENT              : 
CONTINUE             : 72
DIVISION             : 89
DOT                  : 55
ELSE                 : 66
ELSEIF               : 65
EQ                   : 100
FALSE                : 76
FOR                  : 68
GE                   : 99
GT                   : 98
ID                   : 8 24 26 30 35 36 55 55 56 68
IF                   : 60
IN                   : 68
INTEGER              : 73
INT_TYPE             : 18
LCB                  : 8 37
LE                   : 97
LP                   : 30 57 60 65 68 69 84 109
LT                   : 96
MODULO               : 90
MULTIPLICATION       : 88
NE                   : 101
NOT                  : 105
NUMERROR             : 
OR                   : 95
POWER                : 91
PRINT                : 57
RCB                  : 8 37
REAL                 : 74
REAL_TYPE            : 19
REFERENCE            : 5
RETURN               : 70
RP                   : 30 57 60 65 68 69 84 109
SEMICOLON            : 13 41 42 52 57 58 59 70 71 72
SHIFT_LEFT           : 92
SHIFT_RIGHT          : 93
STATIC               : 16 17 29
STEPS                : 68
STRING               : 5 57 77
STRING_TYPE          : 21
SUBTRACTION          : 87 104
TO                   : 68
TOKENERROR           : 
TRUE                 : 75
VOID                 : 28 29
WHILE                : 69
WHITESPACE           : 
error                : 

Nonterminals, with rules where they appear

actual_arguments     : 109
actual_arguments_list : 110 112
assignment           : 43
binary_operation     : 79
bitwise_operation    : 82
block                : 30 60 65 66 68 69
break                : 50
class                : 6
classes              : 1 6
comparison_operation : 81
continue             : 51
else_block           : 60
elseif               : 63 64
elseif_blocks        : 60
elseifs              : 61 63
exp                  : 24 42 52 60 65 68 68 68 69 70 84 86 86 87 87 88 88 89 89 90 90 91 91 92 92 93 93 94 94 95 95 96 96 97 97 98 98 99 99 100 100 101 101 102 102 103 103 104 105 106 112 113
for                  : 47
formal_argument      : 33 34
formal_arguments     : 30
formal_arguments_list : 31 33
func_body            : 27 28 29
func_dec             : 12
function_call        : 85
function_call_body   : 107 108
if                   : 46
item1                : 25
logical_operation    : 80
lvalue               : 52 78
lvalue1              : 15 17 36 53 59 108
lvalue2              : 54 107
macro                : 2
macros               : 1 2
print                : 44
program              : 0
reference            : 4
return               : 49
return_type          : 14 16 35 58
statement            : 38 39
statement_var_dec    : 45
statements_list      : 37 39
symbol_dec           : 9
symbol_decs          : 8 9
unary_operation      : 83
var_dec              : 11
var_list             : 13 22 58 59
var_list_item        : 22 23
var_type             : 13 27
while                : 48

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . macros classes
    (2) macros -> . macros macro
    (3) macros -> .

    REFERENCE       reduce using rule 3 (macros -> .)
    CLASS           reduce using rule 3 (macros -> .)
    $end            reduce using rule 3 (macros -> .)

    program                        shift and go to state 1
    macros                         shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> macros . classes
    (2) macros -> macros . macro
    (6) classes -> . classes class
    (7) classes -> .
    (4) macro -> . reference
    (5) reference -> . REFERENCE STRING

    CLASS           reduce using rule 7 (classes -> .)
    $end            reduce using rule 7 (classes -> .)
    REFERENCE       shift and go to state 6

    classes                        shift and go to state 3
    macro                          shift and go to state 4
    reference                      shift and go to state 5

state 3

    (1) program -> macros classes .
    (6) classes -> classes . class
    (8) class -> . CLASS ID LCB symbol_decs RCB

    $end            reduce using rule 1 (program -> macros classes .)
    CLASS           shift and go to state 8

    class                          shift and go to state 7

state 4

    (2) macros -> macros macro .

    REFERENCE       reduce using rule 2 (macros -> macros macro .)
    CLASS           reduce using rule 2 (macros -> macros macro .)
    $end            reduce using rule 2 (macros -> macros macro .)


state 5

    (4) macro -> reference .

    REFERENCE       reduce using rule 4 (macro -> reference .)
    CLASS           reduce using rule 4 (macro -> reference .)
    $end            reduce using rule 4 (macro -> reference .)


state 6

    (5) reference -> REFERENCE . STRING

    STRING          shift and go to state 9


state 7

    (6) classes -> classes class .

    CLASS           reduce using rule 6 (classes -> classes class .)
    $end            reduce using rule 6 (classes -> classes class .)


state 8

    (8) class -> CLASS . ID LCB symbol_decs RCB

    ID              shift and go to state 10


state 9

    (5) reference -> REFERENCE STRING .

    REFERENCE       reduce using rule 5 (reference -> REFERENCE STRING .)
    CLASS           reduce using rule 5 (reference -> REFERENCE STRING .)
    $end            reduce using rule 5 (reference -> REFERENCE STRING .)


state 10

    (8) class -> CLASS ID . LCB symbol_decs RCB

    LCB             shift and go to state 11


state 11

    (8) class -> CLASS ID LCB . symbol_decs RCB
    (9) symbol_decs -> . symbol_decs symbol_dec
    (10) symbol_decs -> .

    RCB             reduce using rule 10 (symbol_decs -> .)
    VOID            reduce using rule 10 (symbol_decs -> .)
    STATIC          reduce using rule 10 (symbol_decs -> .)
    INT_TYPE        reduce using rule 10 (symbol_decs -> .)
    REAL_TYPE       reduce using rule 10 (symbol_decs -> .)
    BOOL_TYPE       reduce using rule 10 (symbol_decs -> .)
    STRING_TYPE     reduce using rule 10 (symbol_decs -> .)
    ID              reduce using rule 10 (symbol_decs -> .)

    symbol_decs                    shift and go to state 12

state 12

    (8) class -> CLASS ID LCB symbol_decs . RCB
    (9) symbol_decs -> symbol_decs . symbol_dec
    (11) symbol_dec -> . var_dec
    (12) symbol_dec -> . func_dec
    (13) var_dec -> . var_type var_list SEMICOLON
    (27) func_dec -> . var_type func_body
    (28) func_dec -> . VOID func_body
    (29) func_dec -> . STATIC VOID func_body
    (14) var_type -> . return_type
    (15) var_type -> . lvalue1
    (16) var_type -> . STATIC return_type
    (17) var_type -> . STATIC lvalue1
    (18) return_type -> . INT_TYPE
    (19) return_type -> . REAL_TYPE
    (20) return_type -> . BOOL_TYPE
    (21) return_type -> . STRING_TYPE
    (56) lvalue1 -> . ID

    RCB             shift and go to state 14
    VOID            shift and go to state 19
    STATIC          shift and go to state 20
    INT_TYPE        shift and go to state 23
    REAL_TYPE       shift and go to state 24
    BOOL_TYPE       shift and go to state 25
    STRING_TYPE     shift and go to state 26
    ID              shift and go to state 13

    symbol_dec                     shift and go to state 15
    var_dec                        shift and go to state 16
    func_dec                       shift and go to state 17
    var_type                       shift and go to state 18
    return_type                    shift and go to state 21
    lvalue1                        shift and go to state 22

state 13

    (56) lvalue1 -> ID .

    ID              reduce using rule 56 (lvalue1 -> ID .)


state 14

    (8) class -> CLASS ID LCB symbol_decs RCB .

    CLASS           reduce using rule 8 (class -> CLASS ID LCB symbol_decs RCB .)
    $end            reduce using rule 8 (class -> CLASS ID LCB symbol_decs RCB .)


state 15

    (9) symbol_decs -> symbol_decs symbol_dec .

    RCB             reduce using rule 9 (symbol_decs -> symbol_decs symbol_dec .)
    VOID            reduce using rule 9 (symbol_decs -> symbol_decs symbol_dec .)
    STATIC          reduce using rule 9 (symbol_decs -> symbol_decs symbol_dec .)
    INT_TYPE        reduce using rule 9 (symbol_decs -> symbol_decs symbol_dec .)
    REAL_TYPE       reduce using rule 9 (symbol_decs -> symbol_decs symbol_dec .)
    BOOL_TYPE       reduce using rule 9 (symbol_decs -> symbol_decs symbol_dec .)
    STRING_TYPE     reduce using rule 9 (symbol_decs -> symbol_decs symbol_dec .)
    ID              reduce using rule 9 (symbol_decs -> symbol_decs symbol_dec .)


state 16

    (11) symbol_dec -> var_dec .

    RCB             reduce using rule 11 (symbol_dec -> var_dec .)
    VOID            reduce using rule 11 (symbol_dec -> var_dec .)
    STATIC          reduce using rule 11 (symbol_dec -> var_dec .)
    INT_TYPE        reduce using rule 11 (symbol_dec -> var_dec .)
    REAL_TYPE       reduce using rule 11 (symbol_dec -> var_dec .)
    BOOL_TYPE       reduce using rule 11 (symbol_dec -> var_dec .)
    STRING_TYPE     reduce using rule 11 (symbol_dec -> var_dec .)
    ID              reduce using rule 11 (symbol_dec -> var_dec .)


state 17

    (12) symbol_dec -> func_dec .

    RCB             reduce using rule 12 (symbol_dec -> func_dec .)
    VOID            reduce using rule 12 (symbol_dec -> func_dec .)
    STATIC          reduce using rule 12 (symbol_dec -> func_dec .)
    INT_TYPE        reduce using rule 12 (symbol_dec -> func_dec .)
    REAL_TYPE       reduce using rule 12 (symbol_dec -> func_dec .)
    BOOL_TYPE       reduce using rule 12 (symbol_dec -> func_dec .)
    STRING_TYPE     reduce using rule 12 (symbol_dec -> func_dec .)
    ID              reduce using rule 12 (symbol_dec -> func_dec .)


state 18

    (13) var_dec -> var_type . var_list SEMICOLON
    (27) func_dec -> var_type . func_body
    (22) var_list -> . var_list COMMA var_list_item
    (23) var_list -> . var_list_item
    (30) func_body -> . ID LP formal_arguments RP block
    (25) var_list_item -> . item1
    (26) var_list_item -> . ID
    (24) item1 -> . ID ASSIGNMENT exp

    ID              shift and go to state 30

    var_list                       shift and go to state 27
    func_body                      shift and go to state 28
    var_list_item                  shift and go to state 29
    item1                          shift and go to state 31

state 19

    (28) func_dec -> VOID . func_body
    (30) func_body -> . ID LP formal_arguments RP block

    ID              shift and go to state 33

    func_body                      shift and go to state 32

state 20

    (29) func_dec -> STATIC . VOID func_body
    (16) var_type -> STATIC . return_type
    (17) var_type -> STATIC . lvalue1
    (18) return_type -> . INT_TYPE
    (19) return_type -> . REAL_TYPE
    (20) return_type -> . BOOL_TYPE
    (21) return_type -> . STRING_TYPE
    (56) lvalue1 -> . ID

    VOID            shift and go to state 34
    INT_TYPE        shift and go to state 23
    REAL_TYPE       shift and go to state 24
    BOOL_TYPE       shift and go to state 25
    STRING_TYPE     shift and go to state 26
    ID              shift and go to state 13

    return_type                    shift and go to state 35
    lvalue1                        shift and go to state 36

state 21

    (14) var_type -> return_type .

    ID              reduce using rule 14 (var_type -> return_type .)


state 22

    (15) var_type -> lvalue1 .

    ID              reduce using rule 15 (var_type -> lvalue1 .)


state 23

    (18) return_type -> INT_TYPE .

    ID              reduce using rule 18 (return_type -> INT_TYPE .)


state 24

    (19) return_type -> REAL_TYPE .

    ID              reduce using rule 19 (return_type -> REAL_TYPE .)


state 25

    (20) return_type -> BOOL_TYPE .

    ID              reduce using rule 20 (return_type -> BOOL_TYPE .)


state 26

    (21) return_type -> STRING_TYPE .

    ID              reduce using rule 21 (return_type -> STRING_TYPE .)


state 27

    (13) var_dec -> var_type var_list . SEMICOLON
    (22) var_list -> var_list . COMMA var_list_item

    SEMICOLON       shift and go to state 37
    COMMA           shift and go to state 38


state 28

    (27) func_dec -> var_type func_body .

    RCB             reduce using rule 27 (func_dec -> var_type func_body .)
    VOID            reduce using rule 27 (func_dec -> var_type func_body .)
    STATIC          reduce using rule 27 (func_dec -> var_type func_body .)
    INT_TYPE        reduce using rule 27 (func_dec -> var_type func_body .)
    REAL_TYPE       reduce using rule 27 (func_dec -> var_type func_body .)
    BOOL_TYPE       reduce using rule 27 (func_dec -> var_type func_body .)
    STRING_TYPE     reduce using rule 27 (func_dec -> var_type func_body .)
    ID              reduce using rule 27 (func_dec -> var_type func_body .)


state 29

    (23) var_list -> var_list_item .

    SEMICOLON       reduce using rule 23 (var_list -> var_list_item .)
    COMMA           reduce using rule 23 (var_list -> var_list_item .)


state 30

    (30) func_body -> ID . LP formal_arguments RP block
    (26) var_list_item -> ID .
    (24) item1 -> ID . ASSIGNMENT exp

    LP              shift and go to state 39
    SEMICOLON       reduce using rule 26 (var_list_item -> ID .)
    COMMA           reduce using rule 26 (var_list_item -> ID .)
    ASSIGNMENT      shift and go to state 40


state 31

    (25) var_list_item -> item1 .

    SEMICOLON       reduce using rule 25 (var_list_item -> item1 .)
    COMMA           reduce using rule 25 (var_list_item -> item1 .)


state 32

    (28) func_dec -> VOID func_body .

    RCB             reduce using rule 28 (func_dec -> VOID func_body .)
    VOID            reduce using rule 28 (func_dec -> VOID func_body .)
    STATIC          reduce using rule 28 (func_dec -> VOID func_body .)
    INT_TYPE        reduce using rule 28 (func_dec -> VOID func_body .)
    REAL_TYPE       reduce using rule 28 (func_dec -> VOID func_body .)
    BOOL_TYPE       reduce using rule 28 (func_dec -> VOID func_body .)
    STRING_TYPE     reduce using rule 28 (func_dec -> VOID func_body .)
    ID              reduce using rule 28 (func_dec -> VOID func_body .)


state 33

    (30) func_body -> ID . LP formal_arguments RP block

    LP              shift and go to state 39


state 34

    (29) func_dec -> STATIC VOID . func_body
    (30) func_body -> . ID LP formal_arguments RP block

    ID              shift and go to state 33

    func_body                      shift and go to state 41

state 35

    (16) var_type -> STATIC return_type .

    ID              reduce using rule 16 (var_type -> STATIC return_type .)


state 36

    (17) var_type -> STATIC lvalue1 .

    ID              reduce using rule 17 (var_type -> STATIC lvalue1 .)


state 37

    (13) var_dec -> var_type var_list SEMICOLON .

    RCB             reduce using rule 13 (var_dec -> var_type var_list SEMICOLON .)
    VOID            reduce using rule 13 (var_dec -> var_type var_list SEMICOLON .)
    STATIC          reduce using rule 13 (var_dec -> var_type var_list SEMICOLON .)
    INT_TYPE        reduce using rule 13 (var_dec -> var_type var_list SEMICOLON .)
    REAL_TYPE       reduce using rule 13 (var_dec -> var_type var_list SEMICOLON .)
    BOOL_TYPE       reduce using rule 13 (var_dec -> var_type var_list SEMICOLON .)
    STRING_TYPE     reduce using rule 13 (var_dec -> var_type var_list SEMICOLON .)
    ID              reduce using rule 13 (var_dec -> var_type var_list SEMICOLON .)


state 38

    (22) var_list -> var_list COMMA . var_list_item
    (25) var_list_item -> . item1
    (26) var_list_item -> . ID
    (24) item1 -> . ID ASSIGNMENT exp

    ID              shift and go to state 43

    var_list_item                  shift and go to state 42
    item1                          shift and go to state 31

state 39

    (30) func_body -> ID LP . formal_arguments RP block
    (31) formal_arguments -> . formal_arguments_list
    (32) formal_arguments -> .
    (33) formal_arguments_list -> . formal_arguments_list COMMA formal_argument
    (34) formal_arguments_list -> . formal_argument
    (35) formal_argument -> . return_type ID
    (36) formal_argument -> . lvalue1 ID
    (18) return_type -> . INT_TYPE
    (19) return_type -> . REAL_TYPE
    (20) return_type -> . BOOL_TYPE
    (21) return_type -> . STRING_TYPE
    (56) lvalue1 -> . ID

    RP              reduce using rule 32 (formal_arguments -> .)
    INT_TYPE        shift and go to state 23
    REAL_TYPE       shift and go to state 24
    BOOL_TYPE       shift and go to state 25
    STRING_TYPE     shift and go to state 26
    ID              shift and go to state 13

    formal_arguments               shift and go to state 44
    formal_arguments_list          shift and go to state 45
    formal_argument                shift and go to state 46
    return_type                    shift and go to state 47
    lvalue1                        shift and go to state 48

state 40

    (24) item1 -> ID ASSIGNMENT . exp
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 50
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 41

    (29) func_dec -> STATIC VOID func_body .

    RCB             reduce using rule 29 (func_dec -> STATIC VOID func_body .)
    VOID            reduce using rule 29 (func_dec -> STATIC VOID func_body .)
    STATIC          reduce using rule 29 (func_dec -> STATIC VOID func_body .)
    INT_TYPE        reduce using rule 29 (func_dec -> STATIC VOID func_body .)
    REAL_TYPE       reduce using rule 29 (func_dec -> STATIC VOID func_body .)
    BOOL_TYPE       reduce using rule 29 (func_dec -> STATIC VOID func_body .)
    STRING_TYPE     reduce using rule 29 (func_dec -> STATIC VOID func_body .)
    ID              reduce using rule 29 (func_dec -> STATIC VOID func_body .)


state 42

    (22) var_list -> var_list COMMA var_list_item .

    SEMICOLON       reduce using rule 22 (var_list -> var_list COMMA var_list_item .)
    COMMA           reduce using rule 22 (var_list -> var_list COMMA var_list_item .)


state 43

    (26) var_list_item -> ID .
    (24) item1 -> ID . ASSIGNMENT exp

    SEMICOLON       reduce using rule 26 (var_list_item -> ID .)
    COMMA           reduce using rule 26 (var_list_item -> ID .)
    ASSIGNMENT      shift and go to state 40


state 44

    (30) func_body -> ID LP formal_arguments . RP block

    RP              shift and go to state 69


state 45

    (31) formal_arguments -> formal_arguments_list .
    (33) formal_arguments_list -> formal_arguments_list . COMMA formal_argument

    RP              reduce using rule 31 (formal_arguments -> formal_arguments_list .)
    COMMA           shift and go to state 70


state 46

    (34) formal_arguments_list -> formal_argument .

    COMMA           reduce using rule 34 (formal_arguments_list -> formal_argument .)
    RP              reduce using rule 34 (formal_arguments_list -> formal_argument .)


state 47

    (35) formal_argument -> return_type . ID

    ID              shift and go to state 71


state 48

    (36) formal_argument -> lvalue1 . ID

    ID              shift and go to state 72


state 49

    (56) lvalue1 -> ID .
    (55) lvalue2 -> ID . DOT ID

    LP              reduce using rule 56 (lvalue1 -> ID .)
    ADDITION        reduce using rule 56 (lvalue1 -> ID .)
    SUBTRACTION     reduce using rule 56 (lvalue1 -> ID .)
    MULTIPLICATION  reduce using rule 56 (lvalue1 -> ID .)
    DIVISION        reduce using rule 56 (lvalue1 -> ID .)
    MODULO          reduce using rule 56 (lvalue1 -> ID .)
    POWER           reduce using rule 56 (lvalue1 -> ID .)
    SHIFT_LEFT      reduce using rule 56 (lvalue1 -> ID .)
    SHIFT_RIGHT     reduce using rule 56 (lvalue1 -> ID .)
    AND             reduce using rule 56 (lvalue1 -> ID .)
    OR              reduce using rule 56 (lvalue1 -> ID .)
    LT              reduce using rule 56 (lvalue1 -> ID .)
    LE              reduce using rule 56 (lvalue1 -> ID .)
    GT              reduce using rule 56 (lvalue1 -> ID .)
    GE              reduce using rule 56 (lvalue1 -> ID .)
    EQ              reduce using rule 56 (lvalue1 -> ID .)
    NE              reduce using rule 56 (lvalue1 -> ID .)
    BITWISE_AND     reduce using rule 56 (lvalue1 -> ID .)
    BITWISE_OR      reduce using rule 56 (lvalue1 -> ID .)
    SEMICOLON       reduce using rule 56 (lvalue1 -> ID .)
    COMMA           reduce using rule 56 (lvalue1 -> ID .)
    RP              reduce using rule 56 (lvalue1 -> ID .)
    TO              reduce using rule 56 (lvalue1 -> ID .)
    STEPS           reduce using rule 56 (lvalue1 -> ID .)
    ID              reduce using rule 56 (lvalue1 -> ID .)
    ASSIGNMENT      reduce using rule 56 (lvalue1 -> ID .)
    DOT             shift and go to state 73


state 50

    (24) item1 -> ID ASSIGNMENT exp .
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    SEMICOLON       reduce using rule 24 (item1 -> ID ASSIGNMENT exp .)
    COMMA           reduce using rule 24 (item1 -> ID ASSIGNMENT exp .)
    ADDITION        shift and go to state 74
    SUBTRACTION     shift and go to state 75
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    LT              shift and go to state 84
    LE              shift and go to state 85
    GT              shift and go to state 86
    GE              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91


state 51

    (73) exp -> INTEGER .

    ADDITION        reduce using rule 73 (exp -> INTEGER .)
    SUBTRACTION     reduce using rule 73 (exp -> INTEGER .)
    MULTIPLICATION  reduce using rule 73 (exp -> INTEGER .)
    DIVISION        reduce using rule 73 (exp -> INTEGER .)
    MODULO          reduce using rule 73 (exp -> INTEGER .)
    POWER           reduce using rule 73 (exp -> INTEGER .)
    SHIFT_LEFT      reduce using rule 73 (exp -> INTEGER .)
    SHIFT_RIGHT     reduce using rule 73 (exp -> INTEGER .)
    AND             reduce using rule 73 (exp -> INTEGER .)
    OR              reduce using rule 73 (exp -> INTEGER .)
    LT              reduce using rule 73 (exp -> INTEGER .)
    LE              reduce using rule 73 (exp -> INTEGER .)
    GT              reduce using rule 73 (exp -> INTEGER .)
    GE              reduce using rule 73 (exp -> INTEGER .)
    EQ              reduce using rule 73 (exp -> INTEGER .)
    NE              reduce using rule 73 (exp -> INTEGER .)
    BITWISE_AND     reduce using rule 73 (exp -> INTEGER .)
    BITWISE_OR      reduce using rule 73 (exp -> INTEGER .)
    SEMICOLON       reduce using rule 73 (exp -> INTEGER .)
    COMMA           reduce using rule 73 (exp -> INTEGER .)
    RP              reduce using rule 73 (exp -> INTEGER .)
    TO              reduce using rule 73 (exp -> INTEGER .)
    STEPS           reduce using rule 73 (exp -> INTEGER .)


state 52

    (74) exp -> REAL .

    ADDITION        reduce using rule 74 (exp -> REAL .)
    SUBTRACTION     reduce using rule 74 (exp -> REAL .)
    MULTIPLICATION  reduce using rule 74 (exp -> REAL .)
    DIVISION        reduce using rule 74 (exp -> REAL .)
    MODULO          reduce using rule 74 (exp -> REAL .)
    POWER           reduce using rule 74 (exp -> REAL .)
    SHIFT_LEFT      reduce using rule 74 (exp -> REAL .)
    SHIFT_RIGHT     reduce using rule 74 (exp -> REAL .)
    AND             reduce using rule 74 (exp -> REAL .)
    OR              reduce using rule 74 (exp -> REAL .)
    LT              reduce using rule 74 (exp -> REAL .)
    LE              reduce using rule 74 (exp -> REAL .)
    GT              reduce using rule 74 (exp -> REAL .)
    GE              reduce using rule 74 (exp -> REAL .)
    EQ              reduce using rule 74 (exp -> REAL .)
    NE              reduce using rule 74 (exp -> REAL .)
    BITWISE_AND     reduce using rule 74 (exp -> REAL .)
    BITWISE_OR      reduce using rule 74 (exp -> REAL .)
    SEMICOLON       reduce using rule 74 (exp -> REAL .)
    COMMA           reduce using rule 74 (exp -> REAL .)
    RP              reduce using rule 74 (exp -> REAL .)
    TO              reduce using rule 74 (exp -> REAL .)
    STEPS           reduce using rule 74 (exp -> REAL .)


state 53

    (75) exp -> TRUE .

    ADDITION        reduce using rule 75 (exp -> TRUE .)
    SUBTRACTION     reduce using rule 75 (exp -> TRUE .)
    MULTIPLICATION  reduce using rule 75 (exp -> TRUE .)
    DIVISION        reduce using rule 75 (exp -> TRUE .)
    MODULO          reduce using rule 75 (exp -> TRUE .)
    POWER           reduce using rule 75 (exp -> TRUE .)
    SHIFT_LEFT      reduce using rule 75 (exp -> TRUE .)
    SHIFT_RIGHT     reduce using rule 75 (exp -> TRUE .)
    AND             reduce using rule 75 (exp -> TRUE .)
    OR              reduce using rule 75 (exp -> TRUE .)
    LT              reduce using rule 75 (exp -> TRUE .)
    LE              reduce using rule 75 (exp -> TRUE .)
    GT              reduce using rule 75 (exp -> TRUE .)
    GE              reduce using rule 75 (exp -> TRUE .)
    EQ              reduce using rule 75 (exp -> TRUE .)
    NE              reduce using rule 75 (exp -> TRUE .)
    BITWISE_AND     reduce using rule 75 (exp -> TRUE .)
    BITWISE_OR      reduce using rule 75 (exp -> TRUE .)
    SEMICOLON       reduce using rule 75 (exp -> TRUE .)
    COMMA           reduce using rule 75 (exp -> TRUE .)
    RP              reduce using rule 75 (exp -> TRUE .)
    TO              reduce using rule 75 (exp -> TRUE .)
    STEPS           reduce using rule 75 (exp -> TRUE .)


state 54

    (76) exp -> FALSE .

    ADDITION        reduce using rule 76 (exp -> FALSE .)
    SUBTRACTION     reduce using rule 76 (exp -> FALSE .)
    MULTIPLICATION  reduce using rule 76 (exp -> FALSE .)
    DIVISION        reduce using rule 76 (exp -> FALSE .)
    MODULO          reduce using rule 76 (exp -> FALSE .)
    POWER           reduce using rule 76 (exp -> FALSE .)
    SHIFT_LEFT      reduce using rule 76 (exp -> FALSE .)
    SHIFT_RIGHT     reduce using rule 76 (exp -> FALSE .)
    AND             reduce using rule 76 (exp -> FALSE .)
    OR              reduce using rule 76 (exp -> FALSE .)
    LT              reduce using rule 76 (exp -> FALSE .)
    LE              reduce using rule 76 (exp -> FALSE .)
    GT              reduce using rule 76 (exp -> FALSE .)
    GE              reduce using rule 76 (exp -> FALSE .)
    EQ              reduce using rule 76 (exp -> FALSE .)
    NE              reduce using rule 76 (exp -> FALSE .)
    BITWISE_AND     reduce using rule 76 (exp -> FALSE .)
    BITWISE_OR      reduce using rule 76 (exp -> FALSE .)
    SEMICOLON       reduce using rule 76 (exp -> FALSE .)
    COMMA           reduce using rule 76 (exp -> FALSE .)
    RP              reduce using rule 76 (exp -> FALSE .)
    TO              reduce using rule 76 (exp -> FALSE .)
    STEPS           reduce using rule 76 (exp -> FALSE .)


state 55

    (77) exp -> STRING .

    ADDITION        reduce using rule 77 (exp -> STRING .)
    SUBTRACTION     reduce using rule 77 (exp -> STRING .)
    MULTIPLICATION  reduce using rule 77 (exp -> STRING .)
    DIVISION        reduce using rule 77 (exp -> STRING .)
    MODULO          reduce using rule 77 (exp -> STRING .)
    POWER           reduce using rule 77 (exp -> STRING .)
    SHIFT_LEFT      reduce using rule 77 (exp -> STRING .)
    SHIFT_RIGHT     reduce using rule 77 (exp -> STRING .)
    AND             reduce using rule 77 (exp -> STRING .)
    OR              reduce using rule 77 (exp -> STRING .)
    LT              reduce using rule 77 (exp -> STRING .)
    LE              reduce using rule 77 (exp -> STRING .)
    GT              reduce using rule 77 (exp -> STRING .)
    GE              reduce using rule 77 (exp -> STRING .)
    EQ              reduce using rule 77 (exp -> STRING .)
    NE              reduce using rule 77 (exp -> STRING .)
    BITWISE_AND     reduce using rule 77 (exp -> STRING .)
    BITWISE_OR      reduce using rule 77 (exp -> STRING .)
    SEMICOLON       reduce using rule 77 (exp -> STRING .)
    COMMA           reduce using rule 77 (exp -> STRING .)
    RP              reduce using rule 77 (exp -> STRING .)
    TO              reduce using rule 77 (exp -> STRING .)
    STEPS           reduce using rule 77 (exp -> STRING .)


state 56

    (78) exp -> lvalue .

    ADDITION        reduce using rule 78 (exp -> lvalue .)
    SUBTRACTION     reduce using rule 78 (exp -> lvalue .)
    MULTIPLICATION  reduce using rule 78 (exp -> lvalue .)
    DIVISION        reduce using rule 78 (exp -> lvalue .)
    MODULO          reduce using rule 78 (exp -> lvalue .)
    POWER           reduce using rule 78 (exp -> lvalue .)
    SHIFT_LEFT      reduce using rule 78 (exp -> lvalue .)
    SHIFT_RIGHT     reduce using rule 78 (exp -> lvalue .)
    AND             reduce using rule 78 (exp -> lvalue .)
    OR              reduce using rule 78 (exp -> lvalue .)
    LT              reduce using rule 78 (exp -> lvalue .)
    LE              reduce using rule 78 (exp -> lvalue .)
    GT              reduce using rule 78 (exp -> lvalue .)
    GE              reduce using rule 78 (exp -> lvalue .)
    EQ              reduce using rule 78 (exp -> lvalue .)
    NE              reduce using rule 78 (exp -> lvalue .)
    BITWISE_AND     reduce using rule 78 (exp -> lvalue .)
    BITWISE_OR      reduce using rule 78 (exp -> lvalue .)
    SEMICOLON       reduce using rule 78 (exp -> lvalue .)
    COMMA           reduce using rule 78 (exp -> lvalue .)
    RP              reduce using rule 78 (exp -> lvalue .)
    TO              reduce using rule 78 (exp -> lvalue .)
    STEPS           reduce using rule 78 (exp -> lvalue .)


state 57

    (79) exp -> binary_operation .

    ADDITION        reduce using rule 79 (exp -> binary_operation .)
    SUBTRACTION     reduce using rule 79 (exp -> binary_operation .)
    MULTIPLICATION  reduce using rule 79 (exp -> binary_operation .)
    DIVISION        reduce using rule 79 (exp -> binary_operation .)
    MODULO          reduce using rule 79 (exp -> binary_operation .)
    POWER           reduce using rule 79 (exp -> binary_operation .)
    SHIFT_LEFT      reduce using rule 79 (exp -> binary_operation .)
    SHIFT_RIGHT     reduce using rule 79 (exp -> binary_operation .)
    AND             reduce using rule 79 (exp -> binary_operation .)
    OR              reduce using rule 79 (exp -> binary_operation .)
    LT              reduce using rule 79 (exp -> binary_operation .)
    LE              reduce using rule 79 (exp -> binary_operation .)
    GT              reduce using rule 79 (exp -> binary_operation .)
    GE              reduce using rule 79 (exp -> binary_operation .)
    EQ              reduce using rule 79 (exp -> binary_operation .)
    NE              reduce using rule 79 (exp -> binary_operation .)
    BITWISE_AND     reduce using rule 79 (exp -> binary_operation .)
    BITWISE_OR      reduce using rule 79 (exp -> binary_operation .)
    SEMICOLON       reduce using rule 79 (exp -> binary_operation .)
    COMMA           reduce using rule 79 (exp -> binary_operation .)
    RP              reduce using rule 79 (exp -> binary_operation .)
    TO              reduce using rule 79 (exp -> binary_operation .)
    STEPS           reduce using rule 79 (exp -> binary_operation .)


state 58

    (80) exp -> logical_operation .

    ADDITION        reduce using rule 80 (exp -> logical_operation .)
    SUBTRACTION     reduce using rule 80 (exp -> logical_operation .)
    MULTIPLICATION  reduce using rule 80 (exp -> logical_operation .)
    DIVISION        reduce using rule 80 (exp -> logical_operation .)
    MODULO          reduce using rule 80 (exp -> logical_operation .)
    POWER           reduce using rule 80 (exp -> logical_operation .)
    SHIFT_LEFT      reduce using rule 80 (exp -> logical_operation .)
    SHIFT_RIGHT     reduce using rule 80 (exp -> logical_operation .)
    AND             reduce using rule 80 (exp -> logical_operation .)
    OR              reduce using rule 80 (exp -> logical_operation .)
    LT              reduce using rule 80 (exp -> logical_operation .)
    LE              reduce using rule 80 (exp -> logical_operation .)
    GT              reduce using rule 80 (exp -> logical_operation .)
    GE              reduce using rule 80 (exp -> logical_operation .)
    EQ              reduce using rule 80 (exp -> logical_operation .)
    NE              reduce using rule 80 (exp -> logical_operation .)
    BITWISE_AND     reduce using rule 80 (exp -> logical_operation .)
    BITWISE_OR      reduce using rule 80 (exp -> logical_operation .)
    SEMICOLON       reduce using rule 80 (exp -> logical_operation .)
    COMMA           reduce using rule 80 (exp -> logical_operation .)
    RP              reduce using rule 80 (exp -> logical_operation .)
    TO              reduce using rule 80 (exp -> logical_operation .)
    STEPS           reduce using rule 80 (exp -> logical_operation .)


state 59

    (81) exp -> comparison_operation .

    ADDITION        reduce using rule 81 (exp -> comparison_operation .)
    SUBTRACTION     reduce using rule 81 (exp -> comparison_operation .)
    MULTIPLICATION  reduce using rule 81 (exp -> comparison_operation .)
    DIVISION        reduce using rule 81 (exp -> comparison_operation .)
    MODULO          reduce using rule 81 (exp -> comparison_operation .)
    POWER           reduce using rule 81 (exp -> comparison_operation .)
    SHIFT_LEFT      reduce using rule 81 (exp -> comparison_operation .)
    SHIFT_RIGHT     reduce using rule 81 (exp -> comparison_operation .)
    AND             reduce using rule 81 (exp -> comparison_operation .)
    OR              reduce using rule 81 (exp -> comparison_operation .)
    LT              reduce using rule 81 (exp -> comparison_operation .)
    LE              reduce using rule 81 (exp -> comparison_operation .)
    GT              reduce using rule 81 (exp -> comparison_operation .)
    GE              reduce using rule 81 (exp -> comparison_operation .)
    EQ              reduce using rule 81 (exp -> comparison_operation .)
    NE              reduce using rule 81 (exp -> comparison_operation .)
    BITWISE_AND     reduce using rule 81 (exp -> comparison_operation .)
    BITWISE_OR      reduce using rule 81 (exp -> comparison_operation .)
    SEMICOLON       reduce using rule 81 (exp -> comparison_operation .)
    COMMA           reduce using rule 81 (exp -> comparison_operation .)
    RP              reduce using rule 81 (exp -> comparison_operation .)
    TO              reduce using rule 81 (exp -> comparison_operation .)
    STEPS           reduce using rule 81 (exp -> comparison_operation .)


state 60

    (82) exp -> bitwise_operation .

    ADDITION        reduce using rule 82 (exp -> bitwise_operation .)
    SUBTRACTION     reduce using rule 82 (exp -> bitwise_operation .)
    MULTIPLICATION  reduce using rule 82 (exp -> bitwise_operation .)
    DIVISION        reduce using rule 82 (exp -> bitwise_operation .)
    MODULO          reduce using rule 82 (exp -> bitwise_operation .)
    POWER           reduce using rule 82 (exp -> bitwise_operation .)
    SHIFT_LEFT      reduce using rule 82 (exp -> bitwise_operation .)
    SHIFT_RIGHT     reduce using rule 82 (exp -> bitwise_operation .)
    AND             reduce using rule 82 (exp -> bitwise_operation .)
    OR              reduce using rule 82 (exp -> bitwise_operation .)
    LT              reduce using rule 82 (exp -> bitwise_operation .)
    LE              reduce using rule 82 (exp -> bitwise_operation .)
    GT              reduce using rule 82 (exp -> bitwise_operation .)
    GE              reduce using rule 82 (exp -> bitwise_operation .)
    EQ              reduce using rule 82 (exp -> bitwise_operation .)
    NE              reduce using rule 82 (exp -> bitwise_operation .)
    BITWISE_AND     reduce using rule 82 (exp -> bitwise_operation .)
    BITWISE_OR      reduce using rule 82 (exp -> bitwise_operation .)
    SEMICOLON       reduce using rule 82 (exp -> bitwise_operation .)
    COMMA           reduce using rule 82 (exp -> bitwise_operation .)
    RP              reduce using rule 82 (exp -> bitwise_operation .)
    TO              reduce using rule 82 (exp -> bitwise_operation .)
    STEPS           reduce using rule 82 (exp -> bitwise_operation .)


state 61

    (83) exp -> unary_operation .

    ADDITION        reduce using rule 83 (exp -> unary_operation .)
    SUBTRACTION     reduce using rule 83 (exp -> unary_operation .)
    MULTIPLICATION  reduce using rule 83 (exp -> unary_operation .)
    DIVISION        reduce using rule 83 (exp -> unary_operation .)
    MODULO          reduce using rule 83 (exp -> unary_operation .)
    POWER           reduce using rule 83 (exp -> unary_operation .)
    SHIFT_LEFT      reduce using rule 83 (exp -> unary_operation .)
    SHIFT_RIGHT     reduce using rule 83 (exp -> unary_operation .)
    AND             reduce using rule 83 (exp -> unary_operation .)
    OR              reduce using rule 83 (exp -> unary_operation .)
    LT              reduce using rule 83 (exp -> unary_operation .)
    LE              reduce using rule 83 (exp -> unary_operation .)
    GT              reduce using rule 83 (exp -> unary_operation .)
    GE              reduce using rule 83 (exp -> unary_operation .)
    EQ              reduce using rule 83 (exp -> unary_operation .)
    NE              reduce using rule 83 (exp -> unary_operation .)
    BITWISE_AND     reduce using rule 83 (exp -> unary_operation .)
    BITWISE_OR      reduce using rule 83 (exp -> unary_operation .)
    SEMICOLON       reduce using rule 83 (exp -> unary_operation .)
    COMMA           reduce using rule 83 (exp -> unary_operation .)
    RP              reduce using rule 83 (exp -> unary_operation .)
    TO              reduce using rule 83 (exp -> unary_operation .)
    STEPS           reduce using rule 83 (exp -> unary_operation .)


state 62

    (84) exp -> LP . exp RP
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 92
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 63

    (85) exp -> function_call .

    ADDITION        reduce using rule 85 (exp -> function_call .)
    SUBTRACTION     reduce using rule 85 (exp -> function_call .)
    MULTIPLICATION  reduce using rule 85 (exp -> function_call .)
    DIVISION        reduce using rule 85 (exp -> function_call .)
    MODULO          reduce using rule 85 (exp -> function_call .)
    POWER           reduce using rule 85 (exp -> function_call .)
    SHIFT_LEFT      reduce using rule 85 (exp -> function_call .)
    SHIFT_RIGHT     reduce using rule 85 (exp -> function_call .)
    AND             reduce using rule 85 (exp -> function_call .)
    OR              reduce using rule 85 (exp -> function_call .)
    LT              reduce using rule 85 (exp -> function_call .)
    LE              reduce using rule 85 (exp -> function_call .)
    GT              reduce using rule 85 (exp -> function_call .)
    GE              reduce using rule 85 (exp -> function_call .)
    EQ              reduce using rule 85 (exp -> function_call .)
    NE              reduce using rule 85 (exp -> function_call .)
    BITWISE_AND     reduce using rule 85 (exp -> function_call .)
    BITWISE_OR      reduce using rule 85 (exp -> function_call .)
    SEMICOLON       reduce using rule 85 (exp -> function_call .)
    COMMA           reduce using rule 85 (exp -> function_call .)
    RP              reduce using rule 85 (exp -> function_call .)
    TO              reduce using rule 85 (exp -> function_call .)
    STEPS           reduce using rule 85 (exp -> function_call .)


state 64

    (53) lvalue -> lvalue1 .
    (108) function_call -> lvalue1 . function_call_body
    (109) function_call_body -> . LP actual_arguments RP

    ADDITION        reduce using rule 53 (lvalue -> lvalue1 .)
    SUBTRACTION     reduce using rule 53 (lvalue -> lvalue1 .)
    MULTIPLICATION  reduce using rule 53 (lvalue -> lvalue1 .)
    DIVISION        reduce using rule 53 (lvalue -> lvalue1 .)
    MODULO          reduce using rule 53 (lvalue -> lvalue1 .)
    POWER           reduce using rule 53 (lvalue -> lvalue1 .)
    SHIFT_LEFT      reduce using rule 53 (lvalue -> lvalue1 .)
    SHIFT_RIGHT     reduce using rule 53 (lvalue -> lvalue1 .)
    AND             reduce using rule 53 (lvalue -> lvalue1 .)
    OR              reduce using rule 53 (lvalue -> lvalue1 .)
    LT              reduce using rule 53 (lvalue -> lvalue1 .)
    LE              reduce using rule 53 (lvalue -> lvalue1 .)
    GT              reduce using rule 53 (lvalue -> lvalue1 .)
    GE              reduce using rule 53 (lvalue -> lvalue1 .)
    EQ              reduce using rule 53 (lvalue -> lvalue1 .)
    NE              reduce using rule 53 (lvalue -> lvalue1 .)
    BITWISE_AND     reduce using rule 53 (lvalue -> lvalue1 .)
    BITWISE_OR      reduce using rule 53 (lvalue -> lvalue1 .)
    SEMICOLON       reduce using rule 53 (lvalue -> lvalue1 .)
    COMMA           reduce using rule 53 (lvalue -> lvalue1 .)
    RP              reduce using rule 53 (lvalue -> lvalue1 .)
    TO              reduce using rule 53 (lvalue -> lvalue1 .)
    STEPS           reduce using rule 53 (lvalue -> lvalue1 .)
    LP              shift and go to state 94

    function_call_body             shift and go to state 93

state 65

    (54) lvalue -> lvalue2 .
    (107) function_call -> lvalue2 . function_call_body
    (109) function_call_body -> . LP actual_arguments RP

    ADDITION        reduce using rule 54 (lvalue -> lvalue2 .)
    SUBTRACTION     reduce using rule 54 (lvalue -> lvalue2 .)
    MULTIPLICATION  reduce using rule 54 (lvalue -> lvalue2 .)
    DIVISION        reduce using rule 54 (lvalue -> lvalue2 .)
    MODULO          reduce using rule 54 (lvalue -> lvalue2 .)
    POWER           reduce using rule 54 (lvalue -> lvalue2 .)
    SHIFT_LEFT      reduce using rule 54 (lvalue -> lvalue2 .)
    SHIFT_RIGHT     reduce using rule 54 (lvalue -> lvalue2 .)
    AND             reduce using rule 54 (lvalue -> lvalue2 .)
    OR              reduce using rule 54 (lvalue -> lvalue2 .)
    LT              reduce using rule 54 (lvalue -> lvalue2 .)
    LE              reduce using rule 54 (lvalue -> lvalue2 .)
    GT              reduce using rule 54 (lvalue -> lvalue2 .)
    GE              reduce using rule 54 (lvalue -> lvalue2 .)
    EQ              reduce using rule 54 (lvalue -> lvalue2 .)
    NE              reduce using rule 54 (lvalue -> lvalue2 .)
    BITWISE_AND     reduce using rule 54 (lvalue -> lvalue2 .)
    BITWISE_OR      reduce using rule 54 (lvalue -> lvalue2 .)
    SEMICOLON       reduce using rule 54 (lvalue -> lvalue2 .)
    COMMA           reduce using rule 54 (lvalue -> lvalue2 .)
    RP              reduce using rule 54 (lvalue -> lvalue2 .)
    TO              reduce using rule 54 (lvalue -> lvalue2 .)
    STEPS           reduce using rule 54 (lvalue -> lvalue2 .)
    ASSIGNMENT      reduce using rule 54 (lvalue -> lvalue2 .)
    LP              shift and go to state 94

    function_call_body             shift and go to state 95

state 66

    (104) unary_operation -> SUBTRACTION . exp
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 96
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 67

    (105) unary_operation -> NOT . exp
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 97
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 68

    (106) unary_operation -> BITWISE_NOT . exp
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 98
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 69

    (30) func_body -> ID LP formal_arguments RP . block
    (37) block -> . LCB statements_list RCB
    (38) block -> . statement
    (41) statement -> . SEMICOLON
    (42) statement -> . exp SEMICOLON
    (43) statement -> . assignment
    (44) statement -> . print
    (45) statement -> . statement_var_dec
    (46) statement -> . if
    (47) statement -> . for
    (48) statement -> . while
    (49) statement -> . return
    (50) statement -> . break
    (51) statement -> . continue
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (52) assignment -> . lvalue ASSIGNMENT exp SEMICOLON
    (57) print -> . PRINT LP STRING RP SEMICOLON
    (58) statement_var_dec -> . return_type var_list SEMICOLON
    (59) statement_var_dec -> . lvalue1 var_list SEMICOLON
    (60) if -> . IF LP exp RP block elseif_blocks else_block
    (68) for -> . FOR LP ID IN exp TO exp STEPS exp RP block
    (69) while -> . WHILE LP exp RP block
    (70) return -> . RETURN exp SEMICOLON
    (71) break -> . BREAK SEMICOLON
    (72) continue -> . CONTINUE SEMICOLON
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (18) return_type -> . INT_TYPE
    (19) return_type -> . REAL_TYPE
    (20) return_type -> . BOOL_TYPE
    (21) return_type -> . STRING_TYPE
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    LCB             shift and go to state 100
    SEMICOLON       shift and go to state 102
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    PRINT           shift and go to state 114
    IF              shift and go to state 117
    FOR             shift and go to state 118
    WHILE           shift and go to state 119
    RETURN          shift and go to state 120
    BREAK           shift and go to state 121
    CONTINUE        shift and go to state 122
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    INT_TYPE        shift and go to state 23
    REAL_TYPE       shift and go to state 24
    BOOL_TYPE       shift and go to state 25
    STRING_TYPE     shift and go to state 26
    ID              shift and go to state 49

    block                          shift and go to state 99
    statement                      shift and go to state 101
    exp                            shift and go to state 103
    assignment                     shift and go to state 104
    print                          shift and go to state 105
    statement_var_dec              shift and go to state 106
    if                             shift and go to state 107
    for                            shift and go to state 108
    while                          shift and go to state 109
    return                         shift and go to state 110
    break                          shift and go to state 111
    continue                       shift and go to state 112
    lvalue                         shift and go to state 113
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    return_type                    shift and go to state 115
    lvalue1                        shift and go to state 116
    lvalue2                        shift and go to state 65

state 70

    (33) formal_arguments_list -> formal_arguments_list COMMA . formal_argument
    (35) formal_argument -> . return_type ID
    (36) formal_argument -> . lvalue1 ID
    (18) return_type -> . INT_TYPE
    (19) return_type -> . REAL_TYPE
    (20) return_type -> . BOOL_TYPE
    (21) return_type -> . STRING_TYPE
    (56) lvalue1 -> . ID

    INT_TYPE        shift and go to state 23
    REAL_TYPE       shift and go to state 24
    BOOL_TYPE       shift and go to state 25
    STRING_TYPE     shift and go to state 26
    ID              shift and go to state 13

    formal_argument                shift and go to state 123
    return_type                    shift and go to state 47
    lvalue1                        shift and go to state 48

state 71

    (35) formal_argument -> return_type ID .

    COMMA           reduce using rule 35 (formal_argument -> return_type ID .)
    RP              reduce using rule 35 (formal_argument -> return_type ID .)


state 72

    (36) formal_argument -> lvalue1 ID .

    COMMA           reduce using rule 36 (formal_argument -> lvalue1 ID .)
    RP              reduce using rule 36 (formal_argument -> lvalue1 ID .)


state 73

    (55) lvalue2 -> ID DOT . ID

    ID              shift and go to state 124


state 74

    (86) binary_operation -> exp ADDITION . exp
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 125
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 75

    (87) binary_operation -> exp SUBTRACTION . exp
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 126
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 76

    (88) binary_operation -> exp MULTIPLICATION . exp
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 127
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 77

    (89) binary_operation -> exp DIVISION . exp
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 128
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 78

    (90) binary_operation -> exp MODULO . exp
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 129
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 79

    (91) binary_operation -> exp POWER . exp
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 130
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 80

    (92) binary_operation -> exp SHIFT_LEFT . exp
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 131
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 81

    (93) binary_operation -> exp SHIFT_RIGHT . exp
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 132
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 82

    (94) logical_operation -> exp AND . exp
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 133
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 83

    (95) logical_operation -> exp OR . exp
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 134
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 84

    (96) comparison_operation -> exp LT . exp
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 135
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 85

    (97) comparison_operation -> exp LE . exp
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 136
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 86

    (98) comparison_operation -> exp GT . exp
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 137
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 87

    (99) comparison_operation -> exp GE . exp
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 138
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 88

    (100) comparison_operation -> exp EQ . exp
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 139
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 89

    (101) comparison_operation -> exp NE . exp
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 140
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 90

    (102) bitwise_operation -> exp BITWISE_AND . exp
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 141
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 91

    (103) bitwise_operation -> exp BITWISE_OR . exp
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 142
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 92

    (84) exp -> LP exp . RP
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    RP              shift and go to state 143
    ADDITION        shift and go to state 74
    SUBTRACTION     shift and go to state 75
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    LT              shift and go to state 84
    LE              shift and go to state 85
    GT              shift and go to state 86
    GE              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91


state 93

    (108) function_call -> lvalue1 function_call_body .

    ADDITION        reduce using rule 108 (function_call -> lvalue1 function_call_body .)
    SUBTRACTION     reduce using rule 108 (function_call -> lvalue1 function_call_body .)
    MULTIPLICATION  reduce using rule 108 (function_call -> lvalue1 function_call_body .)
    DIVISION        reduce using rule 108 (function_call -> lvalue1 function_call_body .)
    MODULO          reduce using rule 108 (function_call -> lvalue1 function_call_body .)
    POWER           reduce using rule 108 (function_call -> lvalue1 function_call_body .)
    SHIFT_LEFT      reduce using rule 108 (function_call -> lvalue1 function_call_body .)
    SHIFT_RIGHT     reduce using rule 108 (function_call -> lvalue1 function_call_body .)
    AND             reduce using rule 108 (function_call -> lvalue1 function_call_body .)
    OR              reduce using rule 108 (function_call -> lvalue1 function_call_body .)
    LT              reduce using rule 108 (function_call -> lvalue1 function_call_body .)
    LE              reduce using rule 108 (function_call -> lvalue1 function_call_body .)
    GT              reduce using rule 108 (function_call -> lvalue1 function_call_body .)
    GE              reduce using rule 108 (function_call -> lvalue1 function_call_body .)
    EQ              reduce using rule 108 (function_call -> lvalue1 function_call_body .)
    NE              reduce using rule 108 (function_call -> lvalue1 function_call_body .)
    BITWISE_AND     reduce using rule 108 (function_call -> lvalue1 function_call_body .)
    BITWISE_OR      reduce using rule 108 (function_call -> lvalue1 function_call_body .)
    SEMICOLON       reduce using rule 108 (function_call -> lvalue1 function_call_body .)
    COMMA           reduce using rule 108 (function_call -> lvalue1 function_call_body .)
    RP              reduce using rule 108 (function_call -> lvalue1 function_call_body .)
    TO              reduce using rule 108 (function_call -> lvalue1 function_call_body .)
    STEPS           reduce using rule 108 (function_call -> lvalue1 function_call_body .)


state 94

    (109) function_call_body -> LP . actual_arguments RP
    (110) actual_arguments -> . actual_arguments_list
    (111) actual_arguments -> .
    (112) actual_arguments_list -> . actual_arguments_list COMMA exp
    (113) actual_arguments_list -> . exp
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    RP              reduce using rule 111 (actual_arguments -> .)
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    actual_arguments               shift and go to state 144
    actual_arguments_list          shift and go to state 145
    exp                            shift and go to state 146
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 95

    (107) function_call -> lvalue2 function_call_body .

    ADDITION        reduce using rule 107 (function_call -> lvalue2 function_call_body .)
    SUBTRACTION     reduce using rule 107 (function_call -> lvalue2 function_call_body .)
    MULTIPLICATION  reduce using rule 107 (function_call -> lvalue2 function_call_body .)
    DIVISION        reduce using rule 107 (function_call -> lvalue2 function_call_body .)
    MODULO          reduce using rule 107 (function_call -> lvalue2 function_call_body .)
    POWER           reduce using rule 107 (function_call -> lvalue2 function_call_body .)
    SHIFT_LEFT      reduce using rule 107 (function_call -> lvalue2 function_call_body .)
    SHIFT_RIGHT     reduce using rule 107 (function_call -> lvalue2 function_call_body .)
    AND             reduce using rule 107 (function_call -> lvalue2 function_call_body .)
    OR              reduce using rule 107 (function_call -> lvalue2 function_call_body .)
    LT              reduce using rule 107 (function_call -> lvalue2 function_call_body .)
    LE              reduce using rule 107 (function_call -> lvalue2 function_call_body .)
    GT              reduce using rule 107 (function_call -> lvalue2 function_call_body .)
    GE              reduce using rule 107 (function_call -> lvalue2 function_call_body .)
    EQ              reduce using rule 107 (function_call -> lvalue2 function_call_body .)
    NE              reduce using rule 107 (function_call -> lvalue2 function_call_body .)
    BITWISE_AND     reduce using rule 107 (function_call -> lvalue2 function_call_body .)
    BITWISE_OR      reduce using rule 107 (function_call -> lvalue2 function_call_body .)
    SEMICOLON       reduce using rule 107 (function_call -> lvalue2 function_call_body .)
    COMMA           reduce using rule 107 (function_call -> lvalue2 function_call_body .)
    RP              reduce using rule 107 (function_call -> lvalue2 function_call_body .)
    TO              reduce using rule 107 (function_call -> lvalue2 function_call_body .)
    STEPS           reduce using rule 107 (function_call -> lvalue2 function_call_body .)


state 96

    (104) unary_operation -> SUBTRACTION exp .
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    ADDITION        reduce using rule 104 (unary_operation -> SUBTRACTION exp .)
    SUBTRACTION     reduce using rule 104 (unary_operation -> SUBTRACTION exp .)
    MULTIPLICATION  reduce using rule 104 (unary_operation -> SUBTRACTION exp .)
    DIVISION        reduce using rule 104 (unary_operation -> SUBTRACTION exp .)
    MODULO          reduce using rule 104 (unary_operation -> SUBTRACTION exp .)
    POWER           reduce using rule 104 (unary_operation -> SUBTRACTION exp .)
    SHIFT_LEFT      reduce using rule 104 (unary_operation -> SUBTRACTION exp .)
    SHIFT_RIGHT     reduce using rule 104 (unary_operation -> SUBTRACTION exp .)
    AND             reduce using rule 104 (unary_operation -> SUBTRACTION exp .)
    OR              reduce using rule 104 (unary_operation -> SUBTRACTION exp .)
    LT              reduce using rule 104 (unary_operation -> SUBTRACTION exp .)
    LE              reduce using rule 104 (unary_operation -> SUBTRACTION exp .)
    GT              reduce using rule 104 (unary_operation -> SUBTRACTION exp .)
    GE              reduce using rule 104 (unary_operation -> SUBTRACTION exp .)
    EQ              reduce using rule 104 (unary_operation -> SUBTRACTION exp .)
    NE              reduce using rule 104 (unary_operation -> SUBTRACTION exp .)
    BITWISE_AND     reduce using rule 104 (unary_operation -> SUBTRACTION exp .)
    BITWISE_OR      reduce using rule 104 (unary_operation -> SUBTRACTION exp .)
    SEMICOLON       reduce using rule 104 (unary_operation -> SUBTRACTION exp .)
    COMMA           reduce using rule 104 (unary_operation -> SUBTRACTION exp .)
    RP              reduce using rule 104 (unary_operation -> SUBTRACTION exp .)
    TO              reduce using rule 104 (unary_operation -> SUBTRACTION exp .)
    STEPS           reduce using rule 104 (unary_operation -> SUBTRACTION exp .)

  ! ADDITION        [ shift and go to state 74 ]
  ! SUBTRACTION     [ shift and go to state 75 ]
  ! MULTIPLICATION  [ shift and go to state 76 ]
  ! DIVISION        [ shift and go to state 77 ]
  ! MODULO          [ shift and go to state 78 ]
  ! POWER           [ shift and go to state 79 ]
  ! SHIFT_LEFT      [ shift and go to state 80 ]
  ! SHIFT_RIGHT     [ shift and go to state 81 ]
  ! AND             [ shift and go to state 82 ]
  ! OR              [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! LE              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! GE              [ shift and go to state 87 ]
  ! EQ              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]


state 97

    (105) unary_operation -> NOT exp .
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    AND             reduce using rule 105 (unary_operation -> NOT exp .)
    OR              reduce using rule 105 (unary_operation -> NOT exp .)
    SEMICOLON       reduce using rule 105 (unary_operation -> NOT exp .)
    COMMA           reduce using rule 105 (unary_operation -> NOT exp .)
    RP              reduce using rule 105 (unary_operation -> NOT exp .)
    TO              reduce using rule 105 (unary_operation -> NOT exp .)
    STEPS           reduce using rule 105 (unary_operation -> NOT exp .)
    ADDITION        shift and go to state 74
    SUBTRACTION     shift and go to state 75
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81
    LT              shift and go to state 84
    LE              shift and go to state 85
    GT              shift and go to state 86
    GE              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91

  ! ADDITION        [ reduce using rule 105 (unary_operation -> NOT exp .) ]
  ! SUBTRACTION     [ reduce using rule 105 (unary_operation -> NOT exp .) ]
  ! MULTIPLICATION  [ reduce using rule 105 (unary_operation -> NOT exp .) ]
  ! DIVISION        [ reduce using rule 105 (unary_operation -> NOT exp .) ]
  ! MODULO          [ reduce using rule 105 (unary_operation -> NOT exp .) ]
  ! POWER           [ reduce using rule 105 (unary_operation -> NOT exp .) ]
  ! SHIFT_LEFT      [ reduce using rule 105 (unary_operation -> NOT exp .) ]
  ! SHIFT_RIGHT     [ reduce using rule 105 (unary_operation -> NOT exp .) ]
  ! LT              [ reduce using rule 105 (unary_operation -> NOT exp .) ]
  ! LE              [ reduce using rule 105 (unary_operation -> NOT exp .) ]
  ! GT              [ reduce using rule 105 (unary_operation -> NOT exp .) ]
  ! GE              [ reduce using rule 105 (unary_operation -> NOT exp .) ]
  ! EQ              [ reduce using rule 105 (unary_operation -> NOT exp .) ]
  ! NE              [ reduce using rule 105 (unary_operation -> NOT exp .) ]
  ! BITWISE_AND     [ reduce using rule 105 (unary_operation -> NOT exp .) ]
  ! BITWISE_OR      [ reduce using rule 105 (unary_operation -> NOT exp .) ]
  ! AND             [ shift and go to state 82 ]
  ! OR              [ shift and go to state 83 ]


state 98

    (106) unary_operation -> BITWISE_NOT exp .
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    AND             reduce using rule 106 (unary_operation -> BITWISE_NOT exp .)
    OR              reduce using rule 106 (unary_operation -> BITWISE_NOT exp .)
    BITWISE_AND     reduce using rule 106 (unary_operation -> BITWISE_NOT exp .)
    BITWISE_OR      reduce using rule 106 (unary_operation -> BITWISE_NOT exp .)
    SEMICOLON       reduce using rule 106 (unary_operation -> BITWISE_NOT exp .)
    COMMA           reduce using rule 106 (unary_operation -> BITWISE_NOT exp .)
    RP              reduce using rule 106 (unary_operation -> BITWISE_NOT exp .)
    TO              reduce using rule 106 (unary_operation -> BITWISE_NOT exp .)
    STEPS           reduce using rule 106 (unary_operation -> BITWISE_NOT exp .)
    ADDITION        shift and go to state 74
    SUBTRACTION     shift and go to state 75
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81
    LT              shift and go to state 84
    LE              shift and go to state 85
    GT              shift and go to state 86
    GE              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89

  ! ADDITION        [ reduce using rule 106 (unary_operation -> BITWISE_NOT exp .) ]
  ! SUBTRACTION     [ reduce using rule 106 (unary_operation -> BITWISE_NOT exp .) ]
  ! MULTIPLICATION  [ reduce using rule 106 (unary_operation -> BITWISE_NOT exp .) ]
  ! DIVISION        [ reduce using rule 106 (unary_operation -> BITWISE_NOT exp .) ]
  ! MODULO          [ reduce using rule 106 (unary_operation -> BITWISE_NOT exp .) ]
  ! POWER           [ reduce using rule 106 (unary_operation -> BITWISE_NOT exp .) ]
  ! SHIFT_LEFT      [ reduce using rule 106 (unary_operation -> BITWISE_NOT exp .) ]
  ! SHIFT_RIGHT     [ reduce using rule 106 (unary_operation -> BITWISE_NOT exp .) ]
  ! LT              [ reduce using rule 106 (unary_operation -> BITWISE_NOT exp .) ]
  ! LE              [ reduce using rule 106 (unary_operation -> BITWISE_NOT exp .) ]
  ! GT              [ reduce using rule 106 (unary_operation -> BITWISE_NOT exp .) ]
  ! GE              [ reduce using rule 106 (unary_operation -> BITWISE_NOT exp .) ]
  ! EQ              [ reduce using rule 106 (unary_operation -> BITWISE_NOT exp .) ]
  ! NE              [ reduce using rule 106 (unary_operation -> BITWISE_NOT exp .) ]
  ! AND             [ shift and go to state 82 ]
  ! OR              [ shift and go to state 83 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]


state 99

    (30) func_body -> ID LP formal_arguments RP block .

    RCB             reduce using rule 30 (func_body -> ID LP formal_arguments RP block .)
    VOID            reduce using rule 30 (func_body -> ID LP formal_arguments RP block .)
    STATIC          reduce using rule 30 (func_body -> ID LP formal_arguments RP block .)
    INT_TYPE        reduce using rule 30 (func_body -> ID LP formal_arguments RP block .)
    REAL_TYPE       reduce using rule 30 (func_body -> ID LP formal_arguments RP block .)
    BOOL_TYPE       reduce using rule 30 (func_body -> ID LP formal_arguments RP block .)
    STRING_TYPE     reduce using rule 30 (func_body -> ID LP formal_arguments RP block .)
    ID              reduce using rule 30 (func_body -> ID LP formal_arguments RP block .)


state 100

    (37) block -> LCB . statements_list RCB
    (39) statements_list -> . statements_list statement
    (40) statements_list -> .

    RCB             reduce using rule 40 (statements_list -> .)
    SEMICOLON       reduce using rule 40 (statements_list -> .)
    INTEGER         reduce using rule 40 (statements_list -> .)
    REAL            reduce using rule 40 (statements_list -> .)
    TRUE            reduce using rule 40 (statements_list -> .)
    FALSE           reduce using rule 40 (statements_list -> .)
    STRING          reduce using rule 40 (statements_list -> .)
    LP              reduce using rule 40 (statements_list -> .)
    PRINT           reduce using rule 40 (statements_list -> .)
    IF              reduce using rule 40 (statements_list -> .)
    FOR             reduce using rule 40 (statements_list -> .)
    WHILE           reduce using rule 40 (statements_list -> .)
    RETURN          reduce using rule 40 (statements_list -> .)
    BREAK           reduce using rule 40 (statements_list -> .)
    CONTINUE        reduce using rule 40 (statements_list -> .)
    SUBTRACTION     reduce using rule 40 (statements_list -> .)
    NOT             reduce using rule 40 (statements_list -> .)
    BITWISE_NOT     reduce using rule 40 (statements_list -> .)
    INT_TYPE        reduce using rule 40 (statements_list -> .)
    REAL_TYPE       reduce using rule 40 (statements_list -> .)
    BOOL_TYPE       reduce using rule 40 (statements_list -> .)
    STRING_TYPE     reduce using rule 40 (statements_list -> .)
    ID              reduce using rule 40 (statements_list -> .)

    statements_list                shift and go to state 147

state 101

    (38) block -> statement .

    RCB             reduce using rule 38 (block -> statement .)
    VOID            reduce using rule 38 (block -> statement .)
    STATIC          reduce using rule 38 (block -> statement .)
    INT_TYPE        reduce using rule 38 (block -> statement .)
    REAL_TYPE       reduce using rule 38 (block -> statement .)
    BOOL_TYPE       reduce using rule 38 (block -> statement .)
    STRING_TYPE     reduce using rule 38 (block -> statement .)
    ID              reduce using rule 38 (block -> statement .)
    ELSEIF          reduce using rule 38 (block -> statement .)
    ELSE            reduce using rule 38 (block -> statement .)
    SEMICOLON       reduce using rule 38 (block -> statement .)
    INTEGER         reduce using rule 38 (block -> statement .)
    REAL            reduce using rule 38 (block -> statement .)
    TRUE            reduce using rule 38 (block -> statement .)
    FALSE           reduce using rule 38 (block -> statement .)
    STRING          reduce using rule 38 (block -> statement .)
    LP              reduce using rule 38 (block -> statement .)
    PRINT           reduce using rule 38 (block -> statement .)
    IF              reduce using rule 38 (block -> statement .)
    FOR             reduce using rule 38 (block -> statement .)
    WHILE           reduce using rule 38 (block -> statement .)
    RETURN          reduce using rule 38 (block -> statement .)
    BREAK           reduce using rule 38 (block -> statement .)
    CONTINUE        reduce using rule 38 (block -> statement .)
    SUBTRACTION     reduce using rule 38 (block -> statement .)
    NOT             reduce using rule 38 (block -> statement .)
    BITWISE_NOT     reduce using rule 38 (block -> statement .)


state 102

    (41) statement -> SEMICOLON .

    RCB             reduce using rule 41 (statement -> SEMICOLON .)
    VOID            reduce using rule 41 (statement -> SEMICOLON .)
    STATIC          reduce using rule 41 (statement -> SEMICOLON .)
    INT_TYPE        reduce using rule 41 (statement -> SEMICOLON .)
    REAL_TYPE       reduce using rule 41 (statement -> SEMICOLON .)
    BOOL_TYPE       reduce using rule 41 (statement -> SEMICOLON .)
    STRING_TYPE     reduce using rule 41 (statement -> SEMICOLON .)
    ID              reduce using rule 41 (statement -> SEMICOLON .)
    SEMICOLON       reduce using rule 41 (statement -> SEMICOLON .)
    INTEGER         reduce using rule 41 (statement -> SEMICOLON .)
    REAL            reduce using rule 41 (statement -> SEMICOLON .)
    TRUE            reduce using rule 41 (statement -> SEMICOLON .)
    FALSE           reduce using rule 41 (statement -> SEMICOLON .)
    STRING          reduce using rule 41 (statement -> SEMICOLON .)
    LP              reduce using rule 41 (statement -> SEMICOLON .)
    PRINT           reduce using rule 41 (statement -> SEMICOLON .)
    IF              reduce using rule 41 (statement -> SEMICOLON .)
    FOR             reduce using rule 41 (statement -> SEMICOLON .)
    WHILE           reduce using rule 41 (statement -> SEMICOLON .)
    RETURN          reduce using rule 41 (statement -> SEMICOLON .)
    BREAK           reduce using rule 41 (statement -> SEMICOLON .)
    CONTINUE        reduce using rule 41 (statement -> SEMICOLON .)
    SUBTRACTION     reduce using rule 41 (statement -> SEMICOLON .)
    NOT             reduce using rule 41 (statement -> SEMICOLON .)
    BITWISE_NOT     reduce using rule 41 (statement -> SEMICOLON .)
    ELSEIF          reduce using rule 41 (statement -> SEMICOLON .)
    ELSE            reduce using rule 41 (statement -> SEMICOLON .)


state 103

    (42) statement -> exp . SEMICOLON
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    SEMICOLON       shift and go to state 148
    ADDITION        shift and go to state 74
    SUBTRACTION     shift and go to state 75
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    LT              shift and go to state 84
    LE              shift and go to state 85
    GT              shift and go to state 86
    GE              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91


state 104

    (43) statement -> assignment .

    RCB             reduce using rule 43 (statement -> assignment .)
    VOID            reduce using rule 43 (statement -> assignment .)
    STATIC          reduce using rule 43 (statement -> assignment .)
    INT_TYPE        reduce using rule 43 (statement -> assignment .)
    REAL_TYPE       reduce using rule 43 (statement -> assignment .)
    BOOL_TYPE       reduce using rule 43 (statement -> assignment .)
    STRING_TYPE     reduce using rule 43 (statement -> assignment .)
    ID              reduce using rule 43 (statement -> assignment .)
    SEMICOLON       reduce using rule 43 (statement -> assignment .)
    INTEGER         reduce using rule 43 (statement -> assignment .)
    REAL            reduce using rule 43 (statement -> assignment .)
    TRUE            reduce using rule 43 (statement -> assignment .)
    FALSE           reduce using rule 43 (statement -> assignment .)
    STRING          reduce using rule 43 (statement -> assignment .)
    LP              reduce using rule 43 (statement -> assignment .)
    PRINT           reduce using rule 43 (statement -> assignment .)
    IF              reduce using rule 43 (statement -> assignment .)
    FOR             reduce using rule 43 (statement -> assignment .)
    WHILE           reduce using rule 43 (statement -> assignment .)
    RETURN          reduce using rule 43 (statement -> assignment .)
    BREAK           reduce using rule 43 (statement -> assignment .)
    CONTINUE        reduce using rule 43 (statement -> assignment .)
    SUBTRACTION     reduce using rule 43 (statement -> assignment .)
    NOT             reduce using rule 43 (statement -> assignment .)
    BITWISE_NOT     reduce using rule 43 (statement -> assignment .)
    ELSEIF          reduce using rule 43 (statement -> assignment .)
    ELSE            reduce using rule 43 (statement -> assignment .)


state 105

    (44) statement -> print .

    RCB             reduce using rule 44 (statement -> print .)
    VOID            reduce using rule 44 (statement -> print .)
    STATIC          reduce using rule 44 (statement -> print .)
    INT_TYPE        reduce using rule 44 (statement -> print .)
    REAL_TYPE       reduce using rule 44 (statement -> print .)
    BOOL_TYPE       reduce using rule 44 (statement -> print .)
    STRING_TYPE     reduce using rule 44 (statement -> print .)
    ID              reduce using rule 44 (statement -> print .)
    SEMICOLON       reduce using rule 44 (statement -> print .)
    INTEGER         reduce using rule 44 (statement -> print .)
    REAL            reduce using rule 44 (statement -> print .)
    TRUE            reduce using rule 44 (statement -> print .)
    FALSE           reduce using rule 44 (statement -> print .)
    STRING          reduce using rule 44 (statement -> print .)
    LP              reduce using rule 44 (statement -> print .)
    PRINT           reduce using rule 44 (statement -> print .)
    IF              reduce using rule 44 (statement -> print .)
    FOR             reduce using rule 44 (statement -> print .)
    WHILE           reduce using rule 44 (statement -> print .)
    RETURN          reduce using rule 44 (statement -> print .)
    BREAK           reduce using rule 44 (statement -> print .)
    CONTINUE        reduce using rule 44 (statement -> print .)
    SUBTRACTION     reduce using rule 44 (statement -> print .)
    NOT             reduce using rule 44 (statement -> print .)
    BITWISE_NOT     reduce using rule 44 (statement -> print .)
    ELSEIF          reduce using rule 44 (statement -> print .)
    ELSE            reduce using rule 44 (statement -> print .)


state 106

    (45) statement -> statement_var_dec .

    RCB             reduce using rule 45 (statement -> statement_var_dec .)
    VOID            reduce using rule 45 (statement -> statement_var_dec .)
    STATIC          reduce using rule 45 (statement -> statement_var_dec .)
    INT_TYPE        reduce using rule 45 (statement -> statement_var_dec .)
    REAL_TYPE       reduce using rule 45 (statement -> statement_var_dec .)
    BOOL_TYPE       reduce using rule 45 (statement -> statement_var_dec .)
    STRING_TYPE     reduce using rule 45 (statement -> statement_var_dec .)
    ID              reduce using rule 45 (statement -> statement_var_dec .)
    SEMICOLON       reduce using rule 45 (statement -> statement_var_dec .)
    INTEGER         reduce using rule 45 (statement -> statement_var_dec .)
    REAL            reduce using rule 45 (statement -> statement_var_dec .)
    TRUE            reduce using rule 45 (statement -> statement_var_dec .)
    FALSE           reduce using rule 45 (statement -> statement_var_dec .)
    STRING          reduce using rule 45 (statement -> statement_var_dec .)
    LP              reduce using rule 45 (statement -> statement_var_dec .)
    PRINT           reduce using rule 45 (statement -> statement_var_dec .)
    IF              reduce using rule 45 (statement -> statement_var_dec .)
    FOR             reduce using rule 45 (statement -> statement_var_dec .)
    WHILE           reduce using rule 45 (statement -> statement_var_dec .)
    RETURN          reduce using rule 45 (statement -> statement_var_dec .)
    BREAK           reduce using rule 45 (statement -> statement_var_dec .)
    CONTINUE        reduce using rule 45 (statement -> statement_var_dec .)
    SUBTRACTION     reduce using rule 45 (statement -> statement_var_dec .)
    NOT             reduce using rule 45 (statement -> statement_var_dec .)
    BITWISE_NOT     reduce using rule 45 (statement -> statement_var_dec .)
    ELSEIF          reduce using rule 45 (statement -> statement_var_dec .)
    ELSE            reduce using rule 45 (statement -> statement_var_dec .)


state 107

    (46) statement -> if .

    RCB             reduce using rule 46 (statement -> if .)
    VOID            reduce using rule 46 (statement -> if .)
    STATIC          reduce using rule 46 (statement -> if .)
    INT_TYPE        reduce using rule 46 (statement -> if .)
    REAL_TYPE       reduce using rule 46 (statement -> if .)
    BOOL_TYPE       reduce using rule 46 (statement -> if .)
    STRING_TYPE     reduce using rule 46 (statement -> if .)
    ID              reduce using rule 46 (statement -> if .)
    SEMICOLON       reduce using rule 46 (statement -> if .)
    INTEGER         reduce using rule 46 (statement -> if .)
    REAL            reduce using rule 46 (statement -> if .)
    TRUE            reduce using rule 46 (statement -> if .)
    FALSE           reduce using rule 46 (statement -> if .)
    STRING          reduce using rule 46 (statement -> if .)
    LP              reduce using rule 46 (statement -> if .)
    PRINT           reduce using rule 46 (statement -> if .)
    IF              reduce using rule 46 (statement -> if .)
    FOR             reduce using rule 46 (statement -> if .)
    WHILE           reduce using rule 46 (statement -> if .)
    RETURN          reduce using rule 46 (statement -> if .)
    BREAK           reduce using rule 46 (statement -> if .)
    CONTINUE        reduce using rule 46 (statement -> if .)
    SUBTRACTION     reduce using rule 46 (statement -> if .)
    NOT             reduce using rule 46 (statement -> if .)
    BITWISE_NOT     reduce using rule 46 (statement -> if .)
    ELSEIF          reduce using rule 46 (statement -> if .)
    ELSE            reduce using rule 46 (statement -> if .)


state 108

    (47) statement -> for .

    RCB             reduce using rule 47 (statement -> for .)
    VOID            reduce using rule 47 (statement -> for .)
    STATIC          reduce using rule 47 (statement -> for .)
    INT_TYPE        reduce using rule 47 (statement -> for .)
    REAL_TYPE       reduce using rule 47 (statement -> for .)
    BOOL_TYPE       reduce using rule 47 (statement -> for .)
    STRING_TYPE     reduce using rule 47 (statement -> for .)
    ID              reduce using rule 47 (statement -> for .)
    SEMICOLON       reduce using rule 47 (statement -> for .)
    INTEGER         reduce using rule 47 (statement -> for .)
    REAL            reduce using rule 47 (statement -> for .)
    TRUE            reduce using rule 47 (statement -> for .)
    FALSE           reduce using rule 47 (statement -> for .)
    STRING          reduce using rule 47 (statement -> for .)
    LP              reduce using rule 47 (statement -> for .)
    PRINT           reduce using rule 47 (statement -> for .)
    IF              reduce using rule 47 (statement -> for .)
    FOR             reduce using rule 47 (statement -> for .)
    WHILE           reduce using rule 47 (statement -> for .)
    RETURN          reduce using rule 47 (statement -> for .)
    BREAK           reduce using rule 47 (statement -> for .)
    CONTINUE        reduce using rule 47 (statement -> for .)
    SUBTRACTION     reduce using rule 47 (statement -> for .)
    NOT             reduce using rule 47 (statement -> for .)
    BITWISE_NOT     reduce using rule 47 (statement -> for .)
    ELSEIF          reduce using rule 47 (statement -> for .)
    ELSE            reduce using rule 47 (statement -> for .)


state 109

    (48) statement -> while .

    RCB             reduce using rule 48 (statement -> while .)
    VOID            reduce using rule 48 (statement -> while .)
    STATIC          reduce using rule 48 (statement -> while .)
    INT_TYPE        reduce using rule 48 (statement -> while .)
    REAL_TYPE       reduce using rule 48 (statement -> while .)
    BOOL_TYPE       reduce using rule 48 (statement -> while .)
    STRING_TYPE     reduce using rule 48 (statement -> while .)
    ID              reduce using rule 48 (statement -> while .)
    SEMICOLON       reduce using rule 48 (statement -> while .)
    INTEGER         reduce using rule 48 (statement -> while .)
    REAL            reduce using rule 48 (statement -> while .)
    TRUE            reduce using rule 48 (statement -> while .)
    FALSE           reduce using rule 48 (statement -> while .)
    STRING          reduce using rule 48 (statement -> while .)
    LP              reduce using rule 48 (statement -> while .)
    PRINT           reduce using rule 48 (statement -> while .)
    IF              reduce using rule 48 (statement -> while .)
    FOR             reduce using rule 48 (statement -> while .)
    WHILE           reduce using rule 48 (statement -> while .)
    RETURN          reduce using rule 48 (statement -> while .)
    BREAK           reduce using rule 48 (statement -> while .)
    CONTINUE        reduce using rule 48 (statement -> while .)
    SUBTRACTION     reduce using rule 48 (statement -> while .)
    NOT             reduce using rule 48 (statement -> while .)
    BITWISE_NOT     reduce using rule 48 (statement -> while .)
    ELSEIF          reduce using rule 48 (statement -> while .)
    ELSE            reduce using rule 48 (statement -> while .)


state 110

    (49) statement -> return .

    RCB             reduce using rule 49 (statement -> return .)
    VOID            reduce using rule 49 (statement -> return .)
    STATIC          reduce using rule 49 (statement -> return .)
    INT_TYPE        reduce using rule 49 (statement -> return .)
    REAL_TYPE       reduce using rule 49 (statement -> return .)
    BOOL_TYPE       reduce using rule 49 (statement -> return .)
    STRING_TYPE     reduce using rule 49 (statement -> return .)
    ID              reduce using rule 49 (statement -> return .)
    SEMICOLON       reduce using rule 49 (statement -> return .)
    INTEGER         reduce using rule 49 (statement -> return .)
    REAL            reduce using rule 49 (statement -> return .)
    TRUE            reduce using rule 49 (statement -> return .)
    FALSE           reduce using rule 49 (statement -> return .)
    STRING          reduce using rule 49 (statement -> return .)
    LP              reduce using rule 49 (statement -> return .)
    PRINT           reduce using rule 49 (statement -> return .)
    IF              reduce using rule 49 (statement -> return .)
    FOR             reduce using rule 49 (statement -> return .)
    WHILE           reduce using rule 49 (statement -> return .)
    RETURN          reduce using rule 49 (statement -> return .)
    BREAK           reduce using rule 49 (statement -> return .)
    CONTINUE        reduce using rule 49 (statement -> return .)
    SUBTRACTION     reduce using rule 49 (statement -> return .)
    NOT             reduce using rule 49 (statement -> return .)
    BITWISE_NOT     reduce using rule 49 (statement -> return .)
    ELSEIF          reduce using rule 49 (statement -> return .)
    ELSE            reduce using rule 49 (statement -> return .)


state 111

    (50) statement -> break .

    RCB             reduce using rule 50 (statement -> break .)
    VOID            reduce using rule 50 (statement -> break .)
    STATIC          reduce using rule 50 (statement -> break .)
    INT_TYPE        reduce using rule 50 (statement -> break .)
    REAL_TYPE       reduce using rule 50 (statement -> break .)
    BOOL_TYPE       reduce using rule 50 (statement -> break .)
    STRING_TYPE     reduce using rule 50 (statement -> break .)
    ID              reduce using rule 50 (statement -> break .)
    SEMICOLON       reduce using rule 50 (statement -> break .)
    INTEGER         reduce using rule 50 (statement -> break .)
    REAL            reduce using rule 50 (statement -> break .)
    TRUE            reduce using rule 50 (statement -> break .)
    FALSE           reduce using rule 50 (statement -> break .)
    STRING          reduce using rule 50 (statement -> break .)
    LP              reduce using rule 50 (statement -> break .)
    PRINT           reduce using rule 50 (statement -> break .)
    IF              reduce using rule 50 (statement -> break .)
    FOR             reduce using rule 50 (statement -> break .)
    WHILE           reduce using rule 50 (statement -> break .)
    RETURN          reduce using rule 50 (statement -> break .)
    BREAK           reduce using rule 50 (statement -> break .)
    CONTINUE        reduce using rule 50 (statement -> break .)
    SUBTRACTION     reduce using rule 50 (statement -> break .)
    NOT             reduce using rule 50 (statement -> break .)
    BITWISE_NOT     reduce using rule 50 (statement -> break .)
    ELSEIF          reduce using rule 50 (statement -> break .)
    ELSE            reduce using rule 50 (statement -> break .)


state 112

    (51) statement -> continue .

    RCB             reduce using rule 51 (statement -> continue .)
    VOID            reduce using rule 51 (statement -> continue .)
    STATIC          reduce using rule 51 (statement -> continue .)
    INT_TYPE        reduce using rule 51 (statement -> continue .)
    REAL_TYPE       reduce using rule 51 (statement -> continue .)
    BOOL_TYPE       reduce using rule 51 (statement -> continue .)
    STRING_TYPE     reduce using rule 51 (statement -> continue .)
    ID              reduce using rule 51 (statement -> continue .)
    SEMICOLON       reduce using rule 51 (statement -> continue .)
    INTEGER         reduce using rule 51 (statement -> continue .)
    REAL            reduce using rule 51 (statement -> continue .)
    TRUE            reduce using rule 51 (statement -> continue .)
    FALSE           reduce using rule 51 (statement -> continue .)
    STRING          reduce using rule 51 (statement -> continue .)
    LP              reduce using rule 51 (statement -> continue .)
    PRINT           reduce using rule 51 (statement -> continue .)
    IF              reduce using rule 51 (statement -> continue .)
    FOR             reduce using rule 51 (statement -> continue .)
    WHILE           reduce using rule 51 (statement -> continue .)
    RETURN          reduce using rule 51 (statement -> continue .)
    BREAK           reduce using rule 51 (statement -> continue .)
    CONTINUE        reduce using rule 51 (statement -> continue .)
    SUBTRACTION     reduce using rule 51 (statement -> continue .)
    NOT             reduce using rule 51 (statement -> continue .)
    BITWISE_NOT     reduce using rule 51 (statement -> continue .)
    ELSEIF          reduce using rule 51 (statement -> continue .)
    ELSE            reduce using rule 51 (statement -> continue .)


state 113

    (78) exp -> lvalue .
    (52) assignment -> lvalue . ASSIGNMENT exp SEMICOLON

    SEMICOLON       reduce using rule 78 (exp -> lvalue .)
    ADDITION        reduce using rule 78 (exp -> lvalue .)
    SUBTRACTION     reduce using rule 78 (exp -> lvalue .)
    MULTIPLICATION  reduce using rule 78 (exp -> lvalue .)
    DIVISION        reduce using rule 78 (exp -> lvalue .)
    MODULO          reduce using rule 78 (exp -> lvalue .)
    POWER           reduce using rule 78 (exp -> lvalue .)
    SHIFT_LEFT      reduce using rule 78 (exp -> lvalue .)
    SHIFT_RIGHT     reduce using rule 78 (exp -> lvalue .)
    AND             reduce using rule 78 (exp -> lvalue .)
    OR              reduce using rule 78 (exp -> lvalue .)
    LT              reduce using rule 78 (exp -> lvalue .)
    LE              reduce using rule 78 (exp -> lvalue .)
    GT              reduce using rule 78 (exp -> lvalue .)
    GE              reduce using rule 78 (exp -> lvalue .)
    EQ              reduce using rule 78 (exp -> lvalue .)
    NE              reduce using rule 78 (exp -> lvalue .)
    BITWISE_AND     reduce using rule 78 (exp -> lvalue .)
    BITWISE_OR      reduce using rule 78 (exp -> lvalue .)
    ASSIGNMENT      shift and go to state 149


state 114

    (57) print -> PRINT . LP STRING RP SEMICOLON

    LP              shift and go to state 150


state 115

    (58) statement_var_dec -> return_type . var_list SEMICOLON
    (22) var_list -> . var_list COMMA var_list_item
    (23) var_list -> . var_list_item
    (25) var_list_item -> . item1
    (26) var_list_item -> . ID
    (24) item1 -> . ID ASSIGNMENT exp

    ID              shift and go to state 43

    var_list                       shift and go to state 151
    var_list_item                  shift and go to state 29
    item1                          shift and go to state 31

state 116

    (59) statement_var_dec -> lvalue1 . var_list SEMICOLON
    (53) lvalue -> lvalue1 .
    (108) function_call -> lvalue1 . function_call_body
    (22) var_list -> . var_list COMMA var_list_item
    (23) var_list -> . var_list_item
    (109) function_call_body -> . LP actual_arguments RP
    (25) var_list_item -> . item1
    (26) var_list_item -> . ID
    (24) item1 -> . ID ASSIGNMENT exp

    ASSIGNMENT      reduce using rule 53 (lvalue -> lvalue1 .)
    SEMICOLON       reduce using rule 53 (lvalue -> lvalue1 .)
    ADDITION        reduce using rule 53 (lvalue -> lvalue1 .)
    SUBTRACTION     reduce using rule 53 (lvalue -> lvalue1 .)
    MULTIPLICATION  reduce using rule 53 (lvalue -> lvalue1 .)
    DIVISION        reduce using rule 53 (lvalue -> lvalue1 .)
    MODULO          reduce using rule 53 (lvalue -> lvalue1 .)
    POWER           reduce using rule 53 (lvalue -> lvalue1 .)
    SHIFT_LEFT      reduce using rule 53 (lvalue -> lvalue1 .)
    SHIFT_RIGHT     reduce using rule 53 (lvalue -> lvalue1 .)
    AND             reduce using rule 53 (lvalue -> lvalue1 .)
    OR              reduce using rule 53 (lvalue -> lvalue1 .)
    LT              reduce using rule 53 (lvalue -> lvalue1 .)
    LE              reduce using rule 53 (lvalue -> lvalue1 .)
    GT              reduce using rule 53 (lvalue -> lvalue1 .)
    GE              reduce using rule 53 (lvalue -> lvalue1 .)
    EQ              reduce using rule 53 (lvalue -> lvalue1 .)
    NE              reduce using rule 53 (lvalue -> lvalue1 .)
    BITWISE_AND     reduce using rule 53 (lvalue -> lvalue1 .)
    BITWISE_OR      reduce using rule 53 (lvalue -> lvalue1 .)
    LP              shift and go to state 94
    ID              shift and go to state 43

    var_list                       shift and go to state 152
    function_call_body             shift and go to state 93
    var_list_item                  shift and go to state 29
    item1                          shift and go to state 31

state 117

    (60) if -> IF . LP exp RP block elseif_blocks else_block

    LP              shift and go to state 153


state 118

    (68) for -> FOR . LP ID IN exp TO exp STEPS exp RP block

    LP              shift and go to state 154


state 119

    (69) while -> WHILE . LP exp RP block

    LP              shift and go to state 155


state 120

    (70) return -> RETURN . exp SEMICOLON
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 156
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 121

    (71) break -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 157


state 122

    (72) continue -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 158


state 123

    (33) formal_arguments_list -> formal_arguments_list COMMA formal_argument .

    COMMA           reduce using rule 33 (formal_arguments_list -> formal_arguments_list COMMA formal_argument .)
    RP              reduce using rule 33 (formal_arguments_list -> formal_arguments_list COMMA formal_argument .)


state 124

    (55) lvalue2 -> ID DOT ID .

    LP              reduce using rule 55 (lvalue2 -> ID DOT ID .)
    ADDITION        reduce using rule 55 (lvalue2 -> ID DOT ID .)
    SUBTRACTION     reduce using rule 55 (lvalue2 -> ID DOT ID .)
    MULTIPLICATION  reduce using rule 55 (lvalue2 -> ID DOT ID .)
    DIVISION        reduce using rule 55 (lvalue2 -> ID DOT ID .)
    MODULO          reduce using rule 55 (lvalue2 -> ID DOT ID .)
    POWER           reduce using rule 55 (lvalue2 -> ID DOT ID .)
    SHIFT_LEFT      reduce using rule 55 (lvalue2 -> ID DOT ID .)
    SHIFT_RIGHT     reduce using rule 55 (lvalue2 -> ID DOT ID .)
    AND             reduce using rule 55 (lvalue2 -> ID DOT ID .)
    OR              reduce using rule 55 (lvalue2 -> ID DOT ID .)
    LT              reduce using rule 55 (lvalue2 -> ID DOT ID .)
    LE              reduce using rule 55 (lvalue2 -> ID DOT ID .)
    GT              reduce using rule 55 (lvalue2 -> ID DOT ID .)
    GE              reduce using rule 55 (lvalue2 -> ID DOT ID .)
    EQ              reduce using rule 55 (lvalue2 -> ID DOT ID .)
    NE              reduce using rule 55 (lvalue2 -> ID DOT ID .)
    BITWISE_AND     reduce using rule 55 (lvalue2 -> ID DOT ID .)
    BITWISE_OR      reduce using rule 55 (lvalue2 -> ID DOT ID .)
    SEMICOLON       reduce using rule 55 (lvalue2 -> ID DOT ID .)
    COMMA           reduce using rule 55 (lvalue2 -> ID DOT ID .)
    RP              reduce using rule 55 (lvalue2 -> ID DOT ID .)
    TO              reduce using rule 55 (lvalue2 -> ID DOT ID .)
    STEPS           reduce using rule 55 (lvalue2 -> ID DOT ID .)
    ASSIGNMENT      reduce using rule 55 (lvalue2 -> ID DOT ID .)


state 125

    (86) binary_operation -> exp ADDITION exp .
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    ADDITION        reduce using rule 86 (binary_operation -> exp ADDITION exp .)
    SUBTRACTION     reduce using rule 86 (binary_operation -> exp ADDITION exp .)
    AND             reduce using rule 86 (binary_operation -> exp ADDITION exp .)
    OR              reduce using rule 86 (binary_operation -> exp ADDITION exp .)
    LT              reduce using rule 86 (binary_operation -> exp ADDITION exp .)
    LE              reduce using rule 86 (binary_operation -> exp ADDITION exp .)
    GT              reduce using rule 86 (binary_operation -> exp ADDITION exp .)
    GE              reduce using rule 86 (binary_operation -> exp ADDITION exp .)
    EQ              reduce using rule 86 (binary_operation -> exp ADDITION exp .)
    NE              reduce using rule 86 (binary_operation -> exp ADDITION exp .)
    BITWISE_AND     reduce using rule 86 (binary_operation -> exp ADDITION exp .)
    BITWISE_OR      reduce using rule 86 (binary_operation -> exp ADDITION exp .)
    SEMICOLON       reduce using rule 86 (binary_operation -> exp ADDITION exp .)
    COMMA           reduce using rule 86 (binary_operation -> exp ADDITION exp .)
    RP              reduce using rule 86 (binary_operation -> exp ADDITION exp .)
    TO              reduce using rule 86 (binary_operation -> exp ADDITION exp .)
    STEPS           reduce using rule 86 (binary_operation -> exp ADDITION exp .)
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81

  ! MULTIPLICATION  [ reduce using rule 86 (binary_operation -> exp ADDITION exp .) ]
  ! DIVISION        [ reduce using rule 86 (binary_operation -> exp ADDITION exp .) ]
  ! MODULO          [ reduce using rule 86 (binary_operation -> exp ADDITION exp .) ]
  ! POWER           [ reduce using rule 86 (binary_operation -> exp ADDITION exp .) ]
  ! SHIFT_LEFT      [ reduce using rule 86 (binary_operation -> exp ADDITION exp .) ]
  ! SHIFT_RIGHT     [ reduce using rule 86 (binary_operation -> exp ADDITION exp .) ]
  ! ADDITION        [ shift and go to state 74 ]
  ! SUBTRACTION     [ shift and go to state 75 ]
  ! AND             [ shift and go to state 82 ]
  ! OR              [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! LE              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! GE              [ shift and go to state 87 ]
  ! EQ              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]


state 126

    (87) binary_operation -> exp SUBTRACTION exp .
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    ADDITION        reduce using rule 87 (binary_operation -> exp SUBTRACTION exp .)
    SUBTRACTION     reduce using rule 87 (binary_operation -> exp SUBTRACTION exp .)
    AND             reduce using rule 87 (binary_operation -> exp SUBTRACTION exp .)
    OR              reduce using rule 87 (binary_operation -> exp SUBTRACTION exp .)
    LT              reduce using rule 87 (binary_operation -> exp SUBTRACTION exp .)
    LE              reduce using rule 87 (binary_operation -> exp SUBTRACTION exp .)
    GT              reduce using rule 87 (binary_operation -> exp SUBTRACTION exp .)
    GE              reduce using rule 87 (binary_operation -> exp SUBTRACTION exp .)
    EQ              reduce using rule 87 (binary_operation -> exp SUBTRACTION exp .)
    NE              reduce using rule 87 (binary_operation -> exp SUBTRACTION exp .)
    BITWISE_AND     reduce using rule 87 (binary_operation -> exp SUBTRACTION exp .)
    BITWISE_OR      reduce using rule 87 (binary_operation -> exp SUBTRACTION exp .)
    SEMICOLON       reduce using rule 87 (binary_operation -> exp SUBTRACTION exp .)
    COMMA           reduce using rule 87 (binary_operation -> exp SUBTRACTION exp .)
    RP              reduce using rule 87 (binary_operation -> exp SUBTRACTION exp .)
    TO              reduce using rule 87 (binary_operation -> exp SUBTRACTION exp .)
    STEPS           reduce using rule 87 (binary_operation -> exp SUBTRACTION exp .)
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81

  ! MULTIPLICATION  [ reduce using rule 87 (binary_operation -> exp SUBTRACTION exp .) ]
  ! DIVISION        [ reduce using rule 87 (binary_operation -> exp SUBTRACTION exp .) ]
  ! MODULO          [ reduce using rule 87 (binary_operation -> exp SUBTRACTION exp .) ]
  ! POWER           [ reduce using rule 87 (binary_operation -> exp SUBTRACTION exp .) ]
  ! SHIFT_LEFT      [ reduce using rule 87 (binary_operation -> exp SUBTRACTION exp .) ]
  ! SHIFT_RIGHT     [ reduce using rule 87 (binary_operation -> exp SUBTRACTION exp .) ]
  ! ADDITION        [ shift and go to state 74 ]
  ! SUBTRACTION     [ shift and go to state 75 ]
  ! AND             [ shift and go to state 82 ]
  ! OR              [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! LE              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! GE              [ shift and go to state 87 ]
  ! EQ              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]


state 127

    (88) binary_operation -> exp MULTIPLICATION exp .
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    ADDITION        reduce using rule 88 (binary_operation -> exp MULTIPLICATION exp .)
    SUBTRACTION     reduce using rule 88 (binary_operation -> exp MULTIPLICATION exp .)
    MULTIPLICATION  reduce using rule 88 (binary_operation -> exp MULTIPLICATION exp .)
    DIVISION        reduce using rule 88 (binary_operation -> exp MULTIPLICATION exp .)
    AND             reduce using rule 88 (binary_operation -> exp MULTIPLICATION exp .)
    OR              reduce using rule 88 (binary_operation -> exp MULTIPLICATION exp .)
    LT              reduce using rule 88 (binary_operation -> exp MULTIPLICATION exp .)
    LE              reduce using rule 88 (binary_operation -> exp MULTIPLICATION exp .)
    GT              reduce using rule 88 (binary_operation -> exp MULTIPLICATION exp .)
    GE              reduce using rule 88 (binary_operation -> exp MULTIPLICATION exp .)
    EQ              reduce using rule 88 (binary_operation -> exp MULTIPLICATION exp .)
    NE              reduce using rule 88 (binary_operation -> exp MULTIPLICATION exp .)
    BITWISE_AND     reduce using rule 88 (binary_operation -> exp MULTIPLICATION exp .)
    BITWISE_OR      reduce using rule 88 (binary_operation -> exp MULTIPLICATION exp .)
    SEMICOLON       reduce using rule 88 (binary_operation -> exp MULTIPLICATION exp .)
    COMMA           reduce using rule 88 (binary_operation -> exp MULTIPLICATION exp .)
    RP              reduce using rule 88 (binary_operation -> exp MULTIPLICATION exp .)
    TO              reduce using rule 88 (binary_operation -> exp MULTIPLICATION exp .)
    STEPS           reduce using rule 88 (binary_operation -> exp MULTIPLICATION exp .)
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81

  ! MODULO          [ reduce using rule 88 (binary_operation -> exp MULTIPLICATION exp .) ]
  ! POWER           [ reduce using rule 88 (binary_operation -> exp MULTIPLICATION exp .) ]
  ! SHIFT_LEFT      [ reduce using rule 88 (binary_operation -> exp MULTIPLICATION exp .) ]
  ! SHIFT_RIGHT     [ reduce using rule 88 (binary_operation -> exp MULTIPLICATION exp .) ]
  ! ADDITION        [ shift and go to state 74 ]
  ! SUBTRACTION     [ shift and go to state 75 ]
  ! MULTIPLICATION  [ shift and go to state 76 ]
  ! DIVISION        [ shift and go to state 77 ]
  ! AND             [ shift and go to state 82 ]
  ! OR              [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! LE              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! GE              [ shift and go to state 87 ]
  ! EQ              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]


state 128

    (89) binary_operation -> exp DIVISION exp .
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    ADDITION        reduce using rule 89 (binary_operation -> exp DIVISION exp .)
    SUBTRACTION     reduce using rule 89 (binary_operation -> exp DIVISION exp .)
    MULTIPLICATION  reduce using rule 89 (binary_operation -> exp DIVISION exp .)
    DIVISION        reduce using rule 89 (binary_operation -> exp DIVISION exp .)
    AND             reduce using rule 89 (binary_operation -> exp DIVISION exp .)
    OR              reduce using rule 89 (binary_operation -> exp DIVISION exp .)
    LT              reduce using rule 89 (binary_operation -> exp DIVISION exp .)
    LE              reduce using rule 89 (binary_operation -> exp DIVISION exp .)
    GT              reduce using rule 89 (binary_operation -> exp DIVISION exp .)
    GE              reduce using rule 89 (binary_operation -> exp DIVISION exp .)
    EQ              reduce using rule 89 (binary_operation -> exp DIVISION exp .)
    NE              reduce using rule 89 (binary_operation -> exp DIVISION exp .)
    BITWISE_AND     reduce using rule 89 (binary_operation -> exp DIVISION exp .)
    BITWISE_OR      reduce using rule 89 (binary_operation -> exp DIVISION exp .)
    SEMICOLON       reduce using rule 89 (binary_operation -> exp DIVISION exp .)
    COMMA           reduce using rule 89 (binary_operation -> exp DIVISION exp .)
    RP              reduce using rule 89 (binary_operation -> exp DIVISION exp .)
    TO              reduce using rule 89 (binary_operation -> exp DIVISION exp .)
    STEPS           reduce using rule 89 (binary_operation -> exp DIVISION exp .)
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81

  ! MODULO          [ reduce using rule 89 (binary_operation -> exp DIVISION exp .) ]
  ! POWER           [ reduce using rule 89 (binary_operation -> exp DIVISION exp .) ]
  ! SHIFT_LEFT      [ reduce using rule 89 (binary_operation -> exp DIVISION exp .) ]
  ! SHIFT_RIGHT     [ reduce using rule 89 (binary_operation -> exp DIVISION exp .) ]
  ! ADDITION        [ shift and go to state 74 ]
  ! SUBTRACTION     [ shift and go to state 75 ]
  ! MULTIPLICATION  [ shift and go to state 76 ]
  ! DIVISION        [ shift and go to state 77 ]
  ! AND             [ shift and go to state 82 ]
  ! OR              [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! LE              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! GE              [ shift and go to state 87 ]
  ! EQ              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]


state 129

    (90) binary_operation -> exp MODULO exp .
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    ADDITION        reduce using rule 90 (binary_operation -> exp MODULO exp .)
    SUBTRACTION     reduce using rule 90 (binary_operation -> exp MODULO exp .)
    MULTIPLICATION  reduce using rule 90 (binary_operation -> exp MODULO exp .)
    DIVISION        reduce using rule 90 (binary_operation -> exp MODULO exp .)
    MODULO          reduce using rule 90 (binary_operation -> exp MODULO exp .)
    POWER           reduce using rule 90 (binary_operation -> exp MODULO exp .)
    SHIFT_LEFT      reduce using rule 90 (binary_operation -> exp MODULO exp .)
    SHIFT_RIGHT     reduce using rule 90 (binary_operation -> exp MODULO exp .)
    AND             reduce using rule 90 (binary_operation -> exp MODULO exp .)
    OR              reduce using rule 90 (binary_operation -> exp MODULO exp .)
    LT              reduce using rule 90 (binary_operation -> exp MODULO exp .)
    LE              reduce using rule 90 (binary_operation -> exp MODULO exp .)
    GT              reduce using rule 90 (binary_operation -> exp MODULO exp .)
    GE              reduce using rule 90 (binary_operation -> exp MODULO exp .)
    EQ              reduce using rule 90 (binary_operation -> exp MODULO exp .)
    NE              reduce using rule 90 (binary_operation -> exp MODULO exp .)
    BITWISE_AND     reduce using rule 90 (binary_operation -> exp MODULO exp .)
    BITWISE_OR      reduce using rule 90 (binary_operation -> exp MODULO exp .)
    SEMICOLON       reduce using rule 90 (binary_operation -> exp MODULO exp .)
    COMMA           reduce using rule 90 (binary_operation -> exp MODULO exp .)
    RP              reduce using rule 90 (binary_operation -> exp MODULO exp .)
    TO              reduce using rule 90 (binary_operation -> exp MODULO exp .)
    STEPS           reduce using rule 90 (binary_operation -> exp MODULO exp .)

  ! ADDITION        [ shift and go to state 74 ]
  ! SUBTRACTION     [ shift and go to state 75 ]
  ! MULTIPLICATION  [ shift and go to state 76 ]
  ! DIVISION        [ shift and go to state 77 ]
  ! MODULO          [ shift and go to state 78 ]
  ! POWER           [ shift and go to state 79 ]
  ! SHIFT_LEFT      [ shift and go to state 80 ]
  ! SHIFT_RIGHT     [ shift and go to state 81 ]
  ! AND             [ shift and go to state 82 ]
  ! OR              [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! LE              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! GE              [ shift and go to state 87 ]
  ! EQ              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]


state 130

    (91) binary_operation -> exp POWER exp .
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    ADDITION        reduce using rule 91 (binary_operation -> exp POWER exp .)
    SUBTRACTION     reduce using rule 91 (binary_operation -> exp POWER exp .)
    MULTIPLICATION  reduce using rule 91 (binary_operation -> exp POWER exp .)
    DIVISION        reduce using rule 91 (binary_operation -> exp POWER exp .)
    POWER           reduce using rule 91 (binary_operation -> exp POWER exp .)
    SHIFT_LEFT      reduce using rule 91 (binary_operation -> exp POWER exp .)
    SHIFT_RIGHT     reduce using rule 91 (binary_operation -> exp POWER exp .)
    AND             reduce using rule 91 (binary_operation -> exp POWER exp .)
    OR              reduce using rule 91 (binary_operation -> exp POWER exp .)
    LT              reduce using rule 91 (binary_operation -> exp POWER exp .)
    LE              reduce using rule 91 (binary_operation -> exp POWER exp .)
    GT              reduce using rule 91 (binary_operation -> exp POWER exp .)
    GE              reduce using rule 91 (binary_operation -> exp POWER exp .)
    EQ              reduce using rule 91 (binary_operation -> exp POWER exp .)
    NE              reduce using rule 91 (binary_operation -> exp POWER exp .)
    BITWISE_AND     reduce using rule 91 (binary_operation -> exp POWER exp .)
    BITWISE_OR      reduce using rule 91 (binary_operation -> exp POWER exp .)
    SEMICOLON       reduce using rule 91 (binary_operation -> exp POWER exp .)
    COMMA           reduce using rule 91 (binary_operation -> exp POWER exp .)
    RP              reduce using rule 91 (binary_operation -> exp POWER exp .)
    TO              reduce using rule 91 (binary_operation -> exp POWER exp .)
    STEPS           reduce using rule 91 (binary_operation -> exp POWER exp .)
    MODULO          shift and go to state 78

  ! MODULO          [ reduce using rule 91 (binary_operation -> exp POWER exp .) ]
  ! ADDITION        [ shift and go to state 74 ]
  ! SUBTRACTION     [ shift and go to state 75 ]
  ! MULTIPLICATION  [ shift and go to state 76 ]
  ! DIVISION        [ shift and go to state 77 ]
  ! POWER           [ shift and go to state 79 ]
  ! SHIFT_LEFT      [ shift and go to state 80 ]
  ! SHIFT_RIGHT     [ shift and go to state 81 ]
  ! AND             [ shift and go to state 82 ]
  ! OR              [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! LE              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! GE              [ shift and go to state 87 ]
  ! EQ              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]


state 131

    (92) binary_operation -> exp SHIFT_LEFT exp .
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    ADDITION        reduce using rule 92 (binary_operation -> exp SHIFT_LEFT exp .)
    SUBTRACTION     reduce using rule 92 (binary_operation -> exp SHIFT_LEFT exp .)
    MULTIPLICATION  reduce using rule 92 (binary_operation -> exp SHIFT_LEFT exp .)
    DIVISION        reduce using rule 92 (binary_operation -> exp SHIFT_LEFT exp .)
    SHIFT_LEFT      reduce using rule 92 (binary_operation -> exp SHIFT_LEFT exp .)
    SHIFT_RIGHT     reduce using rule 92 (binary_operation -> exp SHIFT_LEFT exp .)
    AND             reduce using rule 92 (binary_operation -> exp SHIFT_LEFT exp .)
    OR              reduce using rule 92 (binary_operation -> exp SHIFT_LEFT exp .)
    LT              reduce using rule 92 (binary_operation -> exp SHIFT_LEFT exp .)
    LE              reduce using rule 92 (binary_operation -> exp SHIFT_LEFT exp .)
    GT              reduce using rule 92 (binary_operation -> exp SHIFT_LEFT exp .)
    GE              reduce using rule 92 (binary_operation -> exp SHIFT_LEFT exp .)
    EQ              reduce using rule 92 (binary_operation -> exp SHIFT_LEFT exp .)
    NE              reduce using rule 92 (binary_operation -> exp SHIFT_LEFT exp .)
    BITWISE_AND     reduce using rule 92 (binary_operation -> exp SHIFT_LEFT exp .)
    BITWISE_OR      reduce using rule 92 (binary_operation -> exp SHIFT_LEFT exp .)
    SEMICOLON       reduce using rule 92 (binary_operation -> exp SHIFT_LEFT exp .)
    COMMA           reduce using rule 92 (binary_operation -> exp SHIFT_LEFT exp .)
    RP              reduce using rule 92 (binary_operation -> exp SHIFT_LEFT exp .)
    TO              reduce using rule 92 (binary_operation -> exp SHIFT_LEFT exp .)
    STEPS           reduce using rule 92 (binary_operation -> exp SHIFT_LEFT exp .)
    MODULO          shift and go to state 78
    POWER           shift and go to state 79

  ! MODULO          [ reduce using rule 92 (binary_operation -> exp SHIFT_LEFT exp .) ]
  ! POWER           [ reduce using rule 92 (binary_operation -> exp SHIFT_LEFT exp .) ]
  ! ADDITION        [ shift and go to state 74 ]
  ! SUBTRACTION     [ shift and go to state 75 ]
  ! MULTIPLICATION  [ shift and go to state 76 ]
  ! DIVISION        [ shift and go to state 77 ]
  ! SHIFT_LEFT      [ shift and go to state 80 ]
  ! SHIFT_RIGHT     [ shift and go to state 81 ]
  ! AND             [ shift and go to state 82 ]
  ! OR              [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! LE              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! GE              [ shift and go to state 87 ]
  ! EQ              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]


state 132

    (93) binary_operation -> exp SHIFT_RIGHT exp .
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    ADDITION        reduce using rule 93 (binary_operation -> exp SHIFT_RIGHT exp .)
    SUBTRACTION     reduce using rule 93 (binary_operation -> exp SHIFT_RIGHT exp .)
    MULTIPLICATION  reduce using rule 93 (binary_operation -> exp SHIFT_RIGHT exp .)
    DIVISION        reduce using rule 93 (binary_operation -> exp SHIFT_RIGHT exp .)
    SHIFT_LEFT      reduce using rule 93 (binary_operation -> exp SHIFT_RIGHT exp .)
    SHIFT_RIGHT     reduce using rule 93 (binary_operation -> exp SHIFT_RIGHT exp .)
    AND             reduce using rule 93 (binary_operation -> exp SHIFT_RIGHT exp .)
    OR              reduce using rule 93 (binary_operation -> exp SHIFT_RIGHT exp .)
    LT              reduce using rule 93 (binary_operation -> exp SHIFT_RIGHT exp .)
    LE              reduce using rule 93 (binary_operation -> exp SHIFT_RIGHT exp .)
    GT              reduce using rule 93 (binary_operation -> exp SHIFT_RIGHT exp .)
    GE              reduce using rule 93 (binary_operation -> exp SHIFT_RIGHT exp .)
    EQ              reduce using rule 93 (binary_operation -> exp SHIFT_RIGHT exp .)
    NE              reduce using rule 93 (binary_operation -> exp SHIFT_RIGHT exp .)
    BITWISE_AND     reduce using rule 93 (binary_operation -> exp SHIFT_RIGHT exp .)
    BITWISE_OR      reduce using rule 93 (binary_operation -> exp SHIFT_RIGHT exp .)
    SEMICOLON       reduce using rule 93 (binary_operation -> exp SHIFT_RIGHT exp .)
    COMMA           reduce using rule 93 (binary_operation -> exp SHIFT_RIGHT exp .)
    RP              reduce using rule 93 (binary_operation -> exp SHIFT_RIGHT exp .)
    TO              reduce using rule 93 (binary_operation -> exp SHIFT_RIGHT exp .)
    STEPS           reduce using rule 93 (binary_operation -> exp SHIFT_RIGHT exp .)
    MODULO          shift and go to state 78
    POWER           shift and go to state 79

  ! MODULO          [ reduce using rule 93 (binary_operation -> exp SHIFT_RIGHT exp .) ]
  ! POWER           [ reduce using rule 93 (binary_operation -> exp SHIFT_RIGHT exp .) ]
  ! ADDITION        [ shift and go to state 74 ]
  ! SUBTRACTION     [ shift and go to state 75 ]
  ! MULTIPLICATION  [ shift and go to state 76 ]
  ! DIVISION        [ shift and go to state 77 ]
  ! SHIFT_LEFT      [ shift and go to state 80 ]
  ! SHIFT_RIGHT     [ shift and go to state 81 ]
  ! AND             [ shift and go to state 82 ]
  ! OR              [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! LE              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! GE              [ shift and go to state 87 ]
  ! EQ              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]


state 133

    (94) logical_operation -> exp AND exp .
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    AND             reduce using rule 94 (logical_operation -> exp AND exp .)
    OR              reduce using rule 94 (logical_operation -> exp AND exp .)
    SEMICOLON       reduce using rule 94 (logical_operation -> exp AND exp .)
    COMMA           reduce using rule 94 (logical_operation -> exp AND exp .)
    RP              reduce using rule 94 (logical_operation -> exp AND exp .)
    TO              reduce using rule 94 (logical_operation -> exp AND exp .)
    STEPS           reduce using rule 94 (logical_operation -> exp AND exp .)
    ADDITION        shift and go to state 74
    SUBTRACTION     shift and go to state 75
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81
    LT              shift and go to state 84
    LE              shift and go to state 85
    GT              shift and go to state 86
    GE              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91

  ! ADDITION        [ reduce using rule 94 (logical_operation -> exp AND exp .) ]
  ! SUBTRACTION     [ reduce using rule 94 (logical_operation -> exp AND exp .) ]
  ! MULTIPLICATION  [ reduce using rule 94 (logical_operation -> exp AND exp .) ]
  ! DIVISION        [ reduce using rule 94 (logical_operation -> exp AND exp .) ]
  ! MODULO          [ reduce using rule 94 (logical_operation -> exp AND exp .) ]
  ! POWER           [ reduce using rule 94 (logical_operation -> exp AND exp .) ]
  ! SHIFT_LEFT      [ reduce using rule 94 (logical_operation -> exp AND exp .) ]
  ! SHIFT_RIGHT     [ reduce using rule 94 (logical_operation -> exp AND exp .) ]
  ! LT              [ reduce using rule 94 (logical_operation -> exp AND exp .) ]
  ! LE              [ reduce using rule 94 (logical_operation -> exp AND exp .) ]
  ! GT              [ reduce using rule 94 (logical_operation -> exp AND exp .) ]
  ! GE              [ reduce using rule 94 (logical_operation -> exp AND exp .) ]
  ! EQ              [ reduce using rule 94 (logical_operation -> exp AND exp .) ]
  ! NE              [ reduce using rule 94 (logical_operation -> exp AND exp .) ]
  ! BITWISE_AND     [ reduce using rule 94 (logical_operation -> exp AND exp .) ]
  ! BITWISE_OR      [ reduce using rule 94 (logical_operation -> exp AND exp .) ]
  ! AND             [ shift and go to state 82 ]
  ! OR              [ shift and go to state 83 ]


state 134

    (95) logical_operation -> exp OR exp .
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    OR              reduce using rule 95 (logical_operation -> exp OR exp .)
    SEMICOLON       reduce using rule 95 (logical_operation -> exp OR exp .)
    COMMA           reduce using rule 95 (logical_operation -> exp OR exp .)
    RP              reduce using rule 95 (logical_operation -> exp OR exp .)
    TO              reduce using rule 95 (logical_operation -> exp OR exp .)
    STEPS           reduce using rule 95 (logical_operation -> exp OR exp .)
    ADDITION        shift and go to state 74
    SUBTRACTION     shift and go to state 75
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81
    AND             shift and go to state 82
    LT              shift and go to state 84
    LE              shift and go to state 85
    GT              shift and go to state 86
    GE              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91

  ! ADDITION        [ reduce using rule 95 (logical_operation -> exp OR exp .) ]
  ! SUBTRACTION     [ reduce using rule 95 (logical_operation -> exp OR exp .) ]
  ! MULTIPLICATION  [ reduce using rule 95 (logical_operation -> exp OR exp .) ]
  ! DIVISION        [ reduce using rule 95 (logical_operation -> exp OR exp .) ]
  ! MODULO          [ reduce using rule 95 (logical_operation -> exp OR exp .) ]
  ! POWER           [ reduce using rule 95 (logical_operation -> exp OR exp .) ]
  ! SHIFT_LEFT      [ reduce using rule 95 (logical_operation -> exp OR exp .) ]
  ! SHIFT_RIGHT     [ reduce using rule 95 (logical_operation -> exp OR exp .) ]
  ! AND             [ reduce using rule 95 (logical_operation -> exp OR exp .) ]
  ! LT              [ reduce using rule 95 (logical_operation -> exp OR exp .) ]
  ! LE              [ reduce using rule 95 (logical_operation -> exp OR exp .) ]
  ! GT              [ reduce using rule 95 (logical_operation -> exp OR exp .) ]
  ! GE              [ reduce using rule 95 (logical_operation -> exp OR exp .) ]
  ! EQ              [ reduce using rule 95 (logical_operation -> exp OR exp .) ]
  ! NE              [ reduce using rule 95 (logical_operation -> exp OR exp .) ]
  ! BITWISE_AND     [ reduce using rule 95 (logical_operation -> exp OR exp .) ]
  ! BITWISE_OR      [ reduce using rule 95 (logical_operation -> exp OR exp .) ]
  ! OR              [ shift and go to state 83 ]


state 135

    (96) comparison_operation -> exp LT exp .
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    AND             reduce using rule 96 (comparison_operation -> exp LT exp .)
    OR              reduce using rule 96 (comparison_operation -> exp LT exp .)
    LT              reduce using rule 96 (comparison_operation -> exp LT exp .)
    LE              reduce using rule 96 (comparison_operation -> exp LT exp .)
    GT              reduce using rule 96 (comparison_operation -> exp LT exp .)
    GE              reduce using rule 96 (comparison_operation -> exp LT exp .)
    EQ              reduce using rule 96 (comparison_operation -> exp LT exp .)
    NE              reduce using rule 96 (comparison_operation -> exp LT exp .)
    BITWISE_AND     reduce using rule 96 (comparison_operation -> exp LT exp .)
    BITWISE_OR      reduce using rule 96 (comparison_operation -> exp LT exp .)
    SEMICOLON       reduce using rule 96 (comparison_operation -> exp LT exp .)
    COMMA           reduce using rule 96 (comparison_operation -> exp LT exp .)
    RP              reduce using rule 96 (comparison_operation -> exp LT exp .)
    TO              reduce using rule 96 (comparison_operation -> exp LT exp .)
    STEPS           reduce using rule 96 (comparison_operation -> exp LT exp .)
    ADDITION        shift and go to state 74
    SUBTRACTION     shift and go to state 75
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81

  ! ADDITION        [ reduce using rule 96 (comparison_operation -> exp LT exp .) ]
  ! SUBTRACTION     [ reduce using rule 96 (comparison_operation -> exp LT exp .) ]
  ! MULTIPLICATION  [ reduce using rule 96 (comparison_operation -> exp LT exp .) ]
  ! DIVISION        [ reduce using rule 96 (comparison_operation -> exp LT exp .) ]
  ! MODULO          [ reduce using rule 96 (comparison_operation -> exp LT exp .) ]
  ! POWER           [ reduce using rule 96 (comparison_operation -> exp LT exp .) ]
  ! SHIFT_LEFT      [ reduce using rule 96 (comparison_operation -> exp LT exp .) ]
  ! SHIFT_RIGHT     [ reduce using rule 96 (comparison_operation -> exp LT exp .) ]
  ! AND             [ shift and go to state 82 ]
  ! OR              [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! LE              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! GE              [ shift and go to state 87 ]
  ! EQ              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]


state 136

    (97) comparison_operation -> exp LE exp .
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    AND             reduce using rule 97 (comparison_operation -> exp LE exp .)
    OR              reduce using rule 97 (comparison_operation -> exp LE exp .)
    LT              reduce using rule 97 (comparison_operation -> exp LE exp .)
    LE              reduce using rule 97 (comparison_operation -> exp LE exp .)
    GT              reduce using rule 97 (comparison_operation -> exp LE exp .)
    GE              reduce using rule 97 (comparison_operation -> exp LE exp .)
    EQ              reduce using rule 97 (comparison_operation -> exp LE exp .)
    NE              reduce using rule 97 (comparison_operation -> exp LE exp .)
    BITWISE_AND     reduce using rule 97 (comparison_operation -> exp LE exp .)
    BITWISE_OR      reduce using rule 97 (comparison_operation -> exp LE exp .)
    SEMICOLON       reduce using rule 97 (comparison_operation -> exp LE exp .)
    COMMA           reduce using rule 97 (comparison_operation -> exp LE exp .)
    RP              reduce using rule 97 (comparison_operation -> exp LE exp .)
    TO              reduce using rule 97 (comparison_operation -> exp LE exp .)
    STEPS           reduce using rule 97 (comparison_operation -> exp LE exp .)
    ADDITION        shift and go to state 74
    SUBTRACTION     shift and go to state 75
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81

  ! ADDITION        [ reduce using rule 97 (comparison_operation -> exp LE exp .) ]
  ! SUBTRACTION     [ reduce using rule 97 (comparison_operation -> exp LE exp .) ]
  ! MULTIPLICATION  [ reduce using rule 97 (comparison_operation -> exp LE exp .) ]
  ! DIVISION        [ reduce using rule 97 (comparison_operation -> exp LE exp .) ]
  ! MODULO          [ reduce using rule 97 (comparison_operation -> exp LE exp .) ]
  ! POWER           [ reduce using rule 97 (comparison_operation -> exp LE exp .) ]
  ! SHIFT_LEFT      [ reduce using rule 97 (comparison_operation -> exp LE exp .) ]
  ! SHIFT_RIGHT     [ reduce using rule 97 (comparison_operation -> exp LE exp .) ]
  ! AND             [ shift and go to state 82 ]
  ! OR              [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! LE              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! GE              [ shift and go to state 87 ]
  ! EQ              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]


state 137

    (98) comparison_operation -> exp GT exp .
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    AND             reduce using rule 98 (comparison_operation -> exp GT exp .)
    OR              reduce using rule 98 (comparison_operation -> exp GT exp .)
    LT              reduce using rule 98 (comparison_operation -> exp GT exp .)
    LE              reduce using rule 98 (comparison_operation -> exp GT exp .)
    GT              reduce using rule 98 (comparison_operation -> exp GT exp .)
    GE              reduce using rule 98 (comparison_operation -> exp GT exp .)
    EQ              reduce using rule 98 (comparison_operation -> exp GT exp .)
    NE              reduce using rule 98 (comparison_operation -> exp GT exp .)
    BITWISE_AND     reduce using rule 98 (comparison_operation -> exp GT exp .)
    BITWISE_OR      reduce using rule 98 (comparison_operation -> exp GT exp .)
    SEMICOLON       reduce using rule 98 (comparison_operation -> exp GT exp .)
    COMMA           reduce using rule 98 (comparison_operation -> exp GT exp .)
    RP              reduce using rule 98 (comparison_operation -> exp GT exp .)
    TO              reduce using rule 98 (comparison_operation -> exp GT exp .)
    STEPS           reduce using rule 98 (comparison_operation -> exp GT exp .)
    ADDITION        shift and go to state 74
    SUBTRACTION     shift and go to state 75
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81

  ! ADDITION        [ reduce using rule 98 (comparison_operation -> exp GT exp .) ]
  ! SUBTRACTION     [ reduce using rule 98 (comparison_operation -> exp GT exp .) ]
  ! MULTIPLICATION  [ reduce using rule 98 (comparison_operation -> exp GT exp .) ]
  ! DIVISION        [ reduce using rule 98 (comparison_operation -> exp GT exp .) ]
  ! MODULO          [ reduce using rule 98 (comparison_operation -> exp GT exp .) ]
  ! POWER           [ reduce using rule 98 (comparison_operation -> exp GT exp .) ]
  ! SHIFT_LEFT      [ reduce using rule 98 (comparison_operation -> exp GT exp .) ]
  ! SHIFT_RIGHT     [ reduce using rule 98 (comparison_operation -> exp GT exp .) ]
  ! AND             [ shift and go to state 82 ]
  ! OR              [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! LE              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! GE              [ shift and go to state 87 ]
  ! EQ              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]


state 138

    (99) comparison_operation -> exp GE exp .
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    AND             reduce using rule 99 (comparison_operation -> exp GE exp .)
    OR              reduce using rule 99 (comparison_operation -> exp GE exp .)
    LT              reduce using rule 99 (comparison_operation -> exp GE exp .)
    LE              reduce using rule 99 (comparison_operation -> exp GE exp .)
    GT              reduce using rule 99 (comparison_operation -> exp GE exp .)
    GE              reduce using rule 99 (comparison_operation -> exp GE exp .)
    EQ              reduce using rule 99 (comparison_operation -> exp GE exp .)
    NE              reduce using rule 99 (comparison_operation -> exp GE exp .)
    BITWISE_AND     reduce using rule 99 (comparison_operation -> exp GE exp .)
    BITWISE_OR      reduce using rule 99 (comparison_operation -> exp GE exp .)
    SEMICOLON       reduce using rule 99 (comparison_operation -> exp GE exp .)
    COMMA           reduce using rule 99 (comparison_operation -> exp GE exp .)
    RP              reduce using rule 99 (comparison_operation -> exp GE exp .)
    TO              reduce using rule 99 (comparison_operation -> exp GE exp .)
    STEPS           reduce using rule 99 (comparison_operation -> exp GE exp .)
    ADDITION        shift and go to state 74
    SUBTRACTION     shift and go to state 75
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81

  ! ADDITION        [ reduce using rule 99 (comparison_operation -> exp GE exp .) ]
  ! SUBTRACTION     [ reduce using rule 99 (comparison_operation -> exp GE exp .) ]
  ! MULTIPLICATION  [ reduce using rule 99 (comparison_operation -> exp GE exp .) ]
  ! DIVISION        [ reduce using rule 99 (comparison_operation -> exp GE exp .) ]
  ! MODULO          [ reduce using rule 99 (comparison_operation -> exp GE exp .) ]
  ! POWER           [ reduce using rule 99 (comparison_operation -> exp GE exp .) ]
  ! SHIFT_LEFT      [ reduce using rule 99 (comparison_operation -> exp GE exp .) ]
  ! SHIFT_RIGHT     [ reduce using rule 99 (comparison_operation -> exp GE exp .) ]
  ! AND             [ shift and go to state 82 ]
  ! OR              [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! LE              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! GE              [ shift and go to state 87 ]
  ! EQ              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]


state 139

    (100) comparison_operation -> exp EQ exp .
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    AND             reduce using rule 100 (comparison_operation -> exp EQ exp .)
    OR              reduce using rule 100 (comparison_operation -> exp EQ exp .)
    LT              reduce using rule 100 (comparison_operation -> exp EQ exp .)
    LE              reduce using rule 100 (comparison_operation -> exp EQ exp .)
    GT              reduce using rule 100 (comparison_operation -> exp EQ exp .)
    GE              reduce using rule 100 (comparison_operation -> exp EQ exp .)
    EQ              reduce using rule 100 (comparison_operation -> exp EQ exp .)
    NE              reduce using rule 100 (comparison_operation -> exp EQ exp .)
    BITWISE_AND     reduce using rule 100 (comparison_operation -> exp EQ exp .)
    BITWISE_OR      reduce using rule 100 (comparison_operation -> exp EQ exp .)
    SEMICOLON       reduce using rule 100 (comparison_operation -> exp EQ exp .)
    COMMA           reduce using rule 100 (comparison_operation -> exp EQ exp .)
    RP              reduce using rule 100 (comparison_operation -> exp EQ exp .)
    TO              reduce using rule 100 (comparison_operation -> exp EQ exp .)
    STEPS           reduce using rule 100 (comparison_operation -> exp EQ exp .)
    ADDITION        shift and go to state 74
    SUBTRACTION     shift and go to state 75
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81

  ! ADDITION        [ reduce using rule 100 (comparison_operation -> exp EQ exp .) ]
  ! SUBTRACTION     [ reduce using rule 100 (comparison_operation -> exp EQ exp .) ]
  ! MULTIPLICATION  [ reduce using rule 100 (comparison_operation -> exp EQ exp .) ]
  ! DIVISION        [ reduce using rule 100 (comparison_operation -> exp EQ exp .) ]
  ! MODULO          [ reduce using rule 100 (comparison_operation -> exp EQ exp .) ]
  ! POWER           [ reduce using rule 100 (comparison_operation -> exp EQ exp .) ]
  ! SHIFT_LEFT      [ reduce using rule 100 (comparison_operation -> exp EQ exp .) ]
  ! SHIFT_RIGHT     [ reduce using rule 100 (comparison_operation -> exp EQ exp .) ]
  ! AND             [ shift and go to state 82 ]
  ! OR              [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! LE              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! GE              [ shift and go to state 87 ]
  ! EQ              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]


state 140

    (101) comparison_operation -> exp NE exp .
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    AND             reduce using rule 101 (comparison_operation -> exp NE exp .)
    OR              reduce using rule 101 (comparison_operation -> exp NE exp .)
    LT              reduce using rule 101 (comparison_operation -> exp NE exp .)
    LE              reduce using rule 101 (comparison_operation -> exp NE exp .)
    GT              reduce using rule 101 (comparison_operation -> exp NE exp .)
    GE              reduce using rule 101 (comparison_operation -> exp NE exp .)
    EQ              reduce using rule 101 (comparison_operation -> exp NE exp .)
    NE              reduce using rule 101 (comparison_operation -> exp NE exp .)
    BITWISE_AND     reduce using rule 101 (comparison_operation -> exp NE exp .)
    BITWISE_OR      reduce using rule 101 (comparison_operation -> exp NE exp .)
    SEMICOLON       reduce using rule 101 (comparison_operation -> exp NE exp .)
    COMMA           reduce using rule 101 (comparison_operation -> exp NE exp .)
    RP              reduce using rule 101 (comparison_operation -> exp NE exp .)
    TO              reduce using rule 101 (comparison_operation -> exp NE exp .)
    STEPS           reduce using rule 101 (comparison_operation -> exp NE exp .)
    ADDITION        shift and go to state 74
    SUBTRACTION     shift and go to state 75
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81

  ! ADDITION        [ reduce using rule 101 (comparison_operation -> exp NE exp .) ]
  ! SUBTRACTION     [ reduce using rule 101 (comparison_operation -> exp NE exp .) ]
  ! MULTIPLICATION  [ reduce using rule 101 (comparison_operation -> exp NE exp .) ]
  ! DIVISION        [ reduce using rule 101 (comparison_operation -> exp NE exp .) ]
  ! MODULO          [ reduce using rule 101 (comparison_operation -> exp NE exp .) ]
  ! POWER           [ reduce using rule 101 (comparison_operation -> exp NE exp .) ]
  ! SHIFT_LEFT      [ reduce using rule 101 (comparison_operation -> exp NE exp .) ]
  ! SHIFT_RIGHT     [ reduce using rule 101 (comparison_operation -> exp NE exp .) ]
  ! AND             [ shift and go to state 82 ]
  ! OR              [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! LE              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! GE              [ shift and go to state 87 ]
  ! EQ              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]


state 141

    (102) bitwise_operation -> exp BITWISE_AND exp .
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    AND             reduce using rule 102 (bitwise_operation -> exp BITWISE_AND exp .)
    OR              reduce using rule 102 (bitwise_operation -> exp BITWISE_AND exp .)
    BITWISE_AND     reduce using rule 102 (bitwise_operation -> exp BITWISE_AND exp .)
    BITWISE_OR      reduce using rule 102 (bitwise_operation -> exp BITWISE_AND exp .)
    SEMICOLON       reduce using rule 102 (bitwise_operation -> exp BITWISE_AND exp .)
    COMMA           reduce using rule 102 (bitwise_operation -> exp BITWISE_AND exp .)
    RP              reduce using rule 102 (bitwise_operation -> exp BITWISE_AND exp .)
    TO              reduce using rule 102 (bitwise_operation -> exp BITWISE_AND exp .)
    STEPS           reduce using rule 102 (bitwise_operation -> exp BITWISE_AND exp .)
    ADDITION        shift and go to state 74
    SUBTRACTION     shift and go to state 75
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81
    LT              shift and go to state 84
    LE              shift and go to state 85
    GT              shift and go to state 86
    GE              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89

  ! ADDITION        [ reduce using rule 102 (bitwise_operation -> exp BITWISE_AND exp .) ]
  ! SUBTRACTION     [ reduce using rule 102 (bitwise_operation -> exp BITWISE_AND exp .) ]
  ! MULTIPLICATION  [ reduce using rule 102 (bitwise_operation -> exp BITWISE_AND exp .) ]
  ! DIVISION        [ reduce using rule 102 (bitwise_operation -> exp BITWISE_AND exp .) ]
  ! MODULO          [ reduce using rule 102 (bitwise_operation -> exp BITWISE_AND exp .) ]
  ! POWER           [ reduce using rule 102 (bitwise_operation -> exp BITWISE_AND exp .) ]
  ! SHIFT_LEFT      [ reduce using rule 102 (bitwise_operation -> exp BITWISE_AND exp .) ]
  ! SHIFT_RIGHT     [ reduce using rule 102 (bitwise_operation -> exp BITWISE_AND exp .) ]
  ! LT              [ reduce using rule 102 (bitwise_operation -> exp BITWISE_AND exp .) ]
  ! LE              [ reduce using rule 102 (bitwise_operation -> exp BITWISE_AND exp .) ]
  ! GT              [ reduce using rule 102 (bitwise_operation -> exp BITWISE_AND exp .) ]
  ! GE              [ reduce using rule 102 (bitwise_operation -> exp BITWISE_AND exp .) ]
  ! EQ              [ reduce using rule 102 (bitwise_operation -> exp BITWISE_AND exp .) ]
  ! NE              [ reduce using rule 102 (bitwise_operation -> exp BITWISE_AND exp .) ]
  ! AND             [ shift and go to state 82 ]
  ! OR              [ shift and go to state 83 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]


state 142

    (103) bitwise_operation -> exp BITWISE_OR exp .
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    AND             reduce using rule 103 (bitwise_operation -> exp BITWISE_OR exp .)
    OR              reduce using rule 103 (bitwise_operation -> exp BITWISE_OR exp .)
    BITWISE_OR      reduce using rule 103 (bitwise_operation -> exp BITWISE_OR exp .)
    SEMICOLON       reduce using rule 103 (bitwise_operation -> exp BITWISE_OR exp .)
    COMMA           reduce using rule 103 (bitwise_operation -> exp BITWISE_OR exp .)
    RP              reduce using rule 103 (bitwise_operation -> exp BITWISE_OR exp .)
    TO              reduce using rule 103 (bitwise_operation -> exp BITWISE_OR exp .)
    STEPS           reduce using rule 103 (bitwise_operation -> exp BITWISE_OR exp .)
    ADDITION        shift and go to state 74
    SUBTRACTION     shift and go to state 75
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81
    LT              shift and go to state 84
    LE              shift and go to state 85
    GT              shift and go to state 86
    GE              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89
    BITWISE_AND     shift and go to state 90

  ! ADDITION        [ reduce using rule 103 (bitwise_operation -> exp BITWISE_OR exp .) ]
  ! SUBTRACTION     [ reduce using rule 103 (bitwise_operation -> exp BITWISE_OR exp .) ]
  ! MULTIPLICATION  [ reduce using rule 103 (bitwise_operation -> exp BITWISE_OR exp .) ]
  ! DIVISION        [ reduce using rule 103 (bitwise_operation -> exp BITWISE_OR exp .) ]
  ! MODULO          [ reduce using rule 103 (bitwise_operation -> exp BITWISE_OR exp .) ]
  ! POWER           [ reduce using rule 103 (bitwise_operation -> exp BITWISE_OR exp .) ]
  ! SHIFT_LEFT      [ reduce using rule 103 (bitwise_operation -> exp BITWISE_OR exp .) ]
  ! SHIFT_RIGHT     [ reduce using rule 103 (bitwise_operation -> exp BITWISE_OR exp .) ]
  ! LT              [ reduce using rule 103 (bitwise_operation -> exp BITWISE_OR exp .) ]
  ! LE              [ reduce using rule 103 (bitwise_operation -> exp BITWISE_OR exp .) ]
  ! GT              [ reduce using rule 103 (bitwise_operation -> exp BITWISE_OR exp .) ]
  ! GE              [ reduce using rule 103 (bitwise_operation -> exp BITWISE_OR exp .) ]
  ! EQ              [ reduce using rule 103 (bitwise_operation -> exp BITWISE_OR exp .) ]
  ! NE              [ reduce using rule 103 (bitwise_operation -> exp BITWISE_OR exp .) ]
  ! BITWISE_AND     [ reduce using rule 103 (bitwise_operation -> exp BITWISE_OR exp .) ]
  ! AND             [ shift and go to state 82 ]
  ! OR              [ shift and go to state 83 ]
  ! BITWISE_OR      [ shift and go to state 91 ]


state 143

    (84) exp -> LP exp RP .

    ADDITION        reduce using rule 84 (exp -> LP exp RP .)
    SUBTRACTION     reduce using rule 84 (exp -> LP exp RP .)
    MULTIPLICATION  reduce using rule 84 (exp -> LP exp RP .)
    DIVISION        reduce using rule 84 (exp -> LP exp RP .)
    MODULO          reduce using rule 84 (exp -> LP exp RP .)
    POWER           reduce using rule 84 (exp -> LP exp RP .)
    SHIFT_LEFT      reduce using rule 84 (exp -> LP exp RP .)
    SHIFT_RIGHT     reduce using rule 84 (exp -> LP exp RP .)
    AND             reduce using rule 84 (exp -> LP exp RP .)
    OR              reduce using rule 84 (exp -> LP exp RP .)
    LT              reduce using rule 84 (exp -> LP exp RP .)
    LE              reduce using rule 84 (exp -> LP exp RP .)
    GT              reduce using rule 84 (exp -> LP exp RP .)
    GE              reduce using rule 84 (exp -> LP exp RP .)
    EQ              reduce using rule 84 (exp -> LP exp RP .)
    NE              reduce using rule 84 (exp -> LP exp RP .)
    BITWISE_AND     reduce using rule 84 (exp -> LP exp RP .)
    BITWISE_OR      reduce using rule 84 (exp -> LP exp RP .)
    SEMICOLON       reduce using rule 84 (exp -> LP exp RP .)
    COMMA           reduce using rule 84 (exp -> LP exp RP .)
    RP              reduce using rule 84 (exp -> LP exp RP .)
    TO              reduce using rule 84 (exp -> LP exp RP .)
    STEPS           reduce using rule 84 (exp -> LP exp RP .)


state 144

    (109) function_call_body -> LP actual_arguments . RP

    RP              shift and go to state 159


state 145

    (110) actual_arguments -> actual_arguments_list .
    (112) actual_arguments_list -> actual_arguments_list . COMMA exp

    RP              reduce using rule 110 (actual_arguments -> actual_arguments_list .)
    COMMA           shift and go to state 160


state 146

    (113) actual_arguments_list -> exp .
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    COMMA           reduce using rule 113 (actual_arguments_list -> exp .)
    RP              reduce using rule 113 (actual_arguments_list -> exp .)
    ADDITION        shift and go to state 74
    SUBTRACTION     shift and go to state 75
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    LT              shift and go to state 84
    LE              shift and go to state 85
    GT              shift and go to state 86
    GE              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91


state 147

    (37) block -> LCB statements_list . RCB
    (39) statements_list -> statements_list . statement
    (41) statement -> . SEMICOLON
    (42) statement -> . exp SEMICOLON
    (43) statement -> . assignment
    (44) statement -> . print
    (45) statement -> . statement_var_dec
    (46) statement -> . if
    (47) statement -> . for
    (48) statement -> . while
    (49) statement -> . return
    (50) statement -> . break
    (51) statement -> . continue
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (52) assignment -> . lvalue ASSIGNMENT exp SEMICOLON
    (57) print -> . PRINT LP STRING RP SEMICOLON
    (58) statement_var_dec -> . return_type var_list SEMICOLON
    (59) statement_var_dec -> . lvalue1 var_list SEMICOLON
    (60) if -> . IF LP exp RP block elseif_blocks else_block
    (68) for -> . FOR LP ID IN exp TO exp STEPS exp RP block
    (69) while -> . WHILE LP exp RP block
    (70) return -> . RETURN exp SEMICOLON
    (71) break -> . BREAK SEMICOLON
    (72) continue -> . CONTINUE SEMICOLON
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (18) return_type -> . INT_TYPE
    (19) return_type -> . REAL_TYPE
    (20) return_type -> . BOOL_TYPE
    (21) return_type -> . STRING_TYPE
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    RCB             shift and go to state 161
    SEMICOLON       shift and go to state 102
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    PRINT           shift and go to state 114
    IF              shift and go to state 117
    FOR             shift and go to state 118
    WHILE           shift and go to state 119
    RETURN          shift and go to state 120
    BREAK           shift and go to state 121
    CONTINUE        shift and go to state 122
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    INT_TYPE        shift and go to state 23
    REAL_TYPE       shift and go to state 24
    BOOL_TYPE       shift and go to state 25
    STRING_TYPE     shift and go to state 26
    ID              shift and go to state 49

    statement                      shift and go to state 162
    exp                            shift and go to state 103
    assignment                     shift and go to state 104
    print                          shift and go to state 105
    statement_var_dec              shift and go to state 106
    if                             shift and go to state 107
    for                            shift and go to state 108
    while                          shift and go to state 109
    return                         shift and go to state 110
    break                          shift and go to state 111
    continue                       shift and go to state 112
    lvalue                         shift and go to state 113
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    return_type                    shift and go to state 115
    lvalue1                        shift and go to state 116
    lvalue2                        shift and go to state 65

state 148

    (42) statement -> exp SEMICOLON .

    RCB             reduce using rule 42 (statement -> exp SEMICOLON .)
    VOID            reduce using rule 42 (statement -> exp SEMICOLON .)
    STATIC          reduce using rule 42 (statement -> exp SEMICOLON .)
    INT_TYPE        reduce using rule 42 (statement -> exp SEMICOLON .)
    REAL_TYPE       reduce using rule 42 (statement -> exp SEMICOLON .)
    BOOL_TYPE       reduce using rule 42 (statement -> exp SEMICOLON .)
    STRING_TYPE     reduce using rule 42 (statement -> exp SEMICOLON .)
    ID              reduce using rule 42 (statement -> exp SEMICOLON .)
    SEMICOLON       reduce using rule 42 (statement -> exp SEMICOLON .)
    INTEGER         reduce using rule 42 (statement -> exp SEMICOLON .)
    REAL            reduce using rule 42 (statement -> exp SEMICOLON .)
    TRUE            reduce using rule 42 (statement -> exp SEMICOLON .)
    FALSE           reduce using rule 42 (statement -> exp SEMICOLON .)
    STRING          reduce using rule 42 (statement -> exp SEMICOLON .)
    LP              reduce using rule 42 (statement -> exp SEMICOLON .)
    PRINT           reduce using rule 42 (statement -> exp SEMICOLON .)
    IF              reduce using rule 42 (statement -> exp SEMICOLON .)
    FOR             reduce using rule 42 (statement -> exp SEMICOLON .)
    WHILE           reduce using rule 42 (statement -> exp SEMICOLON .)
    RETURN          reduce using rule 42 (statement -> exp SEMICOLON .)
    BREAK           reduce using rule 42 (statement -> exp SEMICOLON .)
    CONTINUE        reduce using rule 42 (statement -> exp SEMICOLON .)
    SUBTRACTION     reduce using rule 42 (statement -> exp SEMICOLON .)
    NOT             reduce using rule 42 (statement -> exp SEMICOLON .)
    BITWISE_NOT     reduce using rule 42 (statement -> exp SEMICOLON .)
    ELSEIF          reduce using rule 42 (statement -> exp SEMICOLON .)
    ELSE            reduce using rule 42 (statement -> exp SEMICOLON .)


state 149

    (52) assignment -> lvalue ASSIGNMENT . exp SEMICOLON
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    lvalue                         shift and go to state 56
    exp                            shift and go to state 163
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 150

    (57) print -> PRINT LP . STRING RP SEMICOLON

    STRING          shift and go to state 164


state 151

    (58) statement_var_dec -> return_type var_list . SEMICOLON
    (22) var_list -> var_list . COMMA var_list_item

    SEMICOLON       shift and go to state 165
    COMMA           shift and go to state 38


state 152

    (59) statement_var_dec -> lvalue1 var_list . SEMICOLON
    (22) var_list -> var_list . COMMA var_list_item

    SEMICOLON       shift and go to state 166
    COMMA           shift and go to state 38


state 153

    (60) if -> IF LP . exp RP block elseif_blocks else_block
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 167
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 154

    (68) for -> FOR LP . ID IN exp TO exp STEPS exp RP block

    ID              shift and go to state 168


state 155

    (69) while -> WHILE LP . exp RP block
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 169
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 156

    (70) return -> RETURN exp . SEMICOLON
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    SEMICOLON       shift and go to state 170
    ADDITION        shift and go to state 74
    SUBTRACTION     shift and go to state 75
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    LT              shift and go to state 84
    LE              shift and go to state 85
    GT              shift and go to state 86
    GE              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91


state 157

    (71) break -> BREAK SEMICOLON .

    RCB             reduce using rule 71 (break -> BREAK SEMICOLON .)
    VOID            reduce using rule 71 (break -> BREAK SEMICOLON .)
    STATIC          reduce using rule 71 (break -> BREAK SEMICOLON .)
    INT_TYPE        reduce using rule 71 (break -> BREAK SEMICOLON .)
    REAL_TYPE       reduce using rule 71 (break -> BREAK SEMICOLON .)
    BOOL_TYPE       reduce using rule 71 (break -> BREAK SEMICOLON .)
    STRING_TYPE     reduce using rule 71 (break -> BREAK SEMICOLON .)
    ID              reduce using rule 71 (break -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 71 (break -> BREAK SEMICOLON .)
    INTEGER         reduce using rule 71 (break -> BREAK SEMICOLON .)
    REAL            reduce using rule 71 (break -> BREAK SEMICOLON .)
    TRUE            reduce using rule 71 (break -> BREAK SEMICOLON .)
    FALSE           reduce using rule 71 (break -> BREAK SEMICOLON .)
    STRING          reduce using rule 71 (break -> BREAK SEMICOLON .)
    LP              reduce using rule 71 (break -> BREAK SEMICOLON .)
    PRINT           reduce using rule 71 (break -> BREAK SEMICOLON .)
    IF              reduce using rule 71 (break -> BREAK SEMICOLON .)
    FOR             reduce using rule 71 (break -> BREAK SEMICOLON .)
    WHILE           reduce using rule 71 (break -> BREAK SEMICOLON .)
    RETURN          reduce using rule 71 (break -> BREAK SEMICOLON .)
    BREAK           reduce using rule 71 (break -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 71 (break -> BREAK SEMICOLON .)
    SUBTRACTION     reduce using rule 71 (break -> BREAK SEMICOLON .)
    NOT             reduce using rule 71 (break -> BREAK SEMICOLON .)
    BITWISE_NOT     reduce using rule 71 (break -> BREAK SEMICOLON .)
    ELSEIF          reduce using rule 71 (break -> BREAK SEMICOLON .)
    ELSE            reduce using rule 71 (break -> BREAK SEMICOLON .)


state 158

    (72) continue -> CONTINUE SEMICOLON .

    RCB             reduce using rule 72 (continue -> CONTINUE SEMICOLON .)
    VOID            reduce using rule 72 (continue -> CONTINUE SEMICOLON .)
    STATIC          reduce using rule 72 (continue -> CONTINUE SEMICOLON .)
    INT_TYPE        reduce using rule 72 (continue -> CONTINUE SEMICOLON .)
    REAL_TYPE       reduce using rule 72 (continue -> CONTINUE SEMICOLON .)
    BOOL_TYPE       reduce using rule 72 (continue -> CONTINUE SEMICOLON .)
    STRING_TYPE     reduce using rule 72 (continue -> CONTINUE SEMICOLON .)
    ID              reduce using rule 72 (continue -> CONTINUE SEMICOLON .)
    SEMICOLON       reduce using rule 72 (continue -> CONTINUE SEMICOLON .)
    INTEGER         reduce using rule 72 (continue -> CONTINUE SEMICOLON .)
    REAL            reduce using rule 72 (continue -> CONTINUE SEMICOLON .)
    TRUE            reduce using rule 72 (continue -> CONTINUE SEMICOLON .)
    FALSE           reduce using rule 72 (continue -> CONTINUE SEMICOLON .)
    STRING          reduce using rule 72 (continue -> CONTINUE SEMICOLON .)
    LP              reduce using rule 72 (continue -> CONTINUE SEMICOLON .)
    PRINT           reduce using rule 72 (continue -> CONTINUE SEMICOLON .)
    IF              reduce using rule 72 (continue -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 72 (continue -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 72 (continue -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 72 (continue -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 72 (continue -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 72 (continue -> CONTINUE SEMICOLON .)
    SUBTRACTION     reduce using rule 72 (continue -> CONTINUE SEMICOLON .)
    NOT             reduce using rule 72 (continue -> CONTINUE SEMICOLON .)
    BITWISE_NOT     reduce using rule 72 (continue -> CONTINUE SEMICOLON .)
    ELSEIF          reduce using rule 72 (continue -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 72 (continue -> CONTINUE SEMICOLON .)


state 159

    (109) function_call_body -> LP actual_arguments RP .

    ADDITION        reduce using rule 109 (function_call_body -> LP actual_arguments RP .)
    SUBTRACTION     reduce using rule 109 (function_call_body -> LP actual_arguments RP .)
    MULTIPLICATION  reduce using rule 109 (function_call_body -> LP actual_arguments RP .)
    DIVISION        reduce using rule 109 (function_call_body -> LP actual_arguments RP .)
    MODULO          reduce using rule 109 (function_call_body -> LP actual_arguments RP .)
    POWER           reduce using rule 109 (function_call_body -> LP actual_arguments RP .)
    SHIFT_LEFT      reduce using rule 109 (function_call_body -> LP actual_arguments RP .)
    SHIFT_RIGHT     reduce using rule 109 (function_call_body -> LP actual_arguments RP .)
    AND             reduce using rule 109 (function_call_body -> LP actual_arguments RP .)
    OR              reduce using rule 109 (function_call_body -> LP actual_arguments RP .)
    LT              reduce using rule 109 (function_call_body -> LP actual_arguments RP .)
    LE              reduce using rule 109 (function_call_body -> LP actual_arguments RP .)
    GT              reduce using rule 109 (function_call_body -> LP actual_arguments RP .)
    GE              reduce using rule 109 (function_call_body -> LP actual_arguments RP .)
    EQ              reduce using rule 109 (function_call_body -> LP actual_arguments RP .)
    NE              reduce using rule 109 (function_call_body -> LP actual_arguments RP .)
    BITWISE_AND     reduce using rule 109 (function_call_body -> LP actual_arguments RP .)
    BITWISE_OR      reduce using rule 109 (function_call_body -> LP actual_arguments RP .)
    SEMICOLON       reduce using rule 109 (function_call_body -> LP actual_arguments RP .)
    COMMA           reduce using rule 109 (function_call_body -> LP actual_arguments RP .)
    RP              reduce using rule 109 (function_call_body -> LP actual_arguments RP .)
    TO              reduce using rule 109 (function_call_body -> LP actual_arguments RP .)
    STEPS           reduce using rule 109 (function_call_body -> LP actual_arguments RP .)


state 160

    (112) actual_arguments_list -> actual_arguments_list COMMA . exp
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 171
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 161

    (37) block -> LCB statements_list RCB .

    RCB             reduce using rule 37 (block -> LCB statements_list RCB .)
    VOID            reduce using rule 37 (block -> LCB statements_list RCB .)
    STATIC          reduce using rule 37 (block -> LCB statements_list RCB .)
    INT_TYPE        reduce using rule 37 (block -> LCB statements_list RCB .)
    REAL_TYPE       reduce using rule 37 (block -> LCB statements_list RCB .)
    BOOL_TYPE       reduce using rule 37 (block -> LCB statements_list RCB .)
    STRING_TYPE     reduce using rule 37 (block -> LCB statements_list RCB .)
    ID              reduce using rule 37 (block -> LCB statements_list RCB .)
    ELSEIF          reduce using rule 37 (block -> LCB statements_list RCB .)
    ELSE            reduce using rule 37 (block -> LCB statements_list RCB .)
    SEMICOLON       reduce using rule 37 (block -> LCB statements_list RCB .)
    INTEGER         reduce using rule 37 (block -> LCB statements_list RCB .)
    REAL            reduce using rule 37 (block -> LCB statements_list RCB .)
    TRUE            reduce using rule 37 (block -> LCB statements_list RCB .)
    FALSE           reduce using rule 37 (block -> LCB statements_list RCB .)
    STRING          reduce using rule 37 (block -> LCB statements_list RCB .)
    LP              reduce using rule 37 (block -> LCB statements_list RCB .)
    PRINT           reduce using rule 37 (block -> LCB statements_list RCB .)
    IF              reduce using rule 37 (block -> LCB statements_list RCB .)
    FOR             reduce using rule 37 (block -> LCB statements_list RCB .)
    WHILE           reduce using rule 37 (block -> LCB statements_list RCB .)
    RETURN          reduce using rule 37 (block -> LCB statements_list RCB .)
    BREAK           reduce using rule 37 (block -> LCB statements_list RCB .)
    CONTINUE        reduce using rule 37 (block -> LCB statements_list RCB .)
    SUBTRACTION     reduce using rule 37 (block -> LCB statements_list RCB .)
    NOT             reduce using rule 37 (block -> LCB statements_list RCB .)
    BITWISE_NOT     reduce using rule 37 (block -> LCB statements_list RCB .)


state 162

    (39) statements_list -> statements_list statement .

    RCB             reduce using rule 39 (statements_list -> statements_list statement .)
    SEMICOLON       reduce using rule 39 (statements_list -> statements_list statement .)
    INTEGER         reduce using rule 39 (statements_list -> statements_list statement .)
    REAL            reduce using rule 39 (statements_list -> statements_list statement .)
    TRUE            reduce using rule 39 (statements_list -> statements_list statement .)
    FALSE           reduce using rule 39 (statements_list -> statements_list statement .)
    STRING          reduce using rule 39 (statements_list -> statements_list statement .)
    LP              reduce using rule 39 (statements_list -> statements_list statement .)
    PRINT           reduce using rule 39 (statements_list -> statements_list statement .)
    IF              reduce using rule 39 (statements_list -> statements_list statement .)
    FOR             reduce using rule 39 (statements_list -> statements_list statement .)
    WHILE           reduce using rule 39 (statements_list -> statements_list statement .)
    RETURN          reduce using rule 39 (statements_list -> statements_list statement .)
    BREAK           reduce using rule 39 (statements_list -> statements_list statement .)
    CONTINUE        reduce using rule 39 (statements_list -> statements_list statement .)
    SUBTRACTION     reduce using rule 39 (statements_list -> statements_list statement .)
    NOT             reduce using rule 39 (statements_list -> statements_list statement .)
    BITWISE_NOT     reduce using rule 39 (statements_list -> statements_list statement .)
    INT_TYPE        reduce using rule 39 (statements_list -> statements_list statement .)
    REAL_TYPE       reduce using rule 39 (statements_list -> statements_list statement .)
    BOOL_TYPE       reduce using rule 39 (statements_list -> statements_list statement .)
    STRING_TYPE     reduce using rule 39 (statements_list -> statements_list statement .)
    ID              reduce using rule 39 (statements_list -> statements_list statement .)


state 163

    (52) assignment -> lvalue ASSIGNMENT exp . SEMICOLON
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    SEMICOLON       shift and go to state 172
    ADDITION        shift and go to state 74
    SUBTRACTION     shift and go to state 75
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    LT              shift and go to state 84
    LE              shift and go to state 85
    GT              shift and go to state 86
    GE              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91


state 164

    (57) print -> PRINT LP STRING . RP SEMICOLON

    RP              shift and go to state 173


state 165

    (58) statement_var_dec -> return_type var_list SEMICOLON .

    RCB             reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)
    VOID            reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)
    STATIC          reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)
    INT_TYPE        reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)
    REAL_TYPE       reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)
    BOOL_TYPE       reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)
    STRING_TYPE     reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)
    ID              reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)
    SEMICOLON       reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)
    INTEGER         reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)
    REAL            reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)
    TRUE            reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)
    FALSE           reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)
    STRING          reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)
    LP              reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)
    PRINT           reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)
    IF              reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)
    FOR             reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)
    WHILE           reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)
    RETURN          reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)
    BREAK           reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)
    CONTINUE        reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)
    SUBTRACTION     reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)
    NOT             reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)
    BITWISE_NOT     reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)
    ELSEIF          reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)
    ELSE            reduce using rule 58 (statement_var_dec -> return_type var_list SEMICOLON .)


state 166

    (59) statement_var_dec -> lvalue1 var_list SEMICOLON .

    RCB             reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)
    VOID            reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)
    STATIC          reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)
    INT_TYPE        reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)
    REAL_TYPE       reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)
    BOOL_TYPE       reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)
    STRING_TYPE     reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)
    ID              reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)
    SEMICOLON       reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)
    INTEGER         reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)
    REAL            reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)
    TRUE            reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)
    FALSE           reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)
    STRING          reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)
    LP              reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)
    PRINT           reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)
    IF              reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)
    FOR             reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)
    WHILE           reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)
    RETURN          reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)
    BREAK           reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)
    CONTINUE        reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)
    SUBTRACTION     reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)
    NOT             reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)
    BITWISE_NOT     reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)
    ELSEIF          reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)
    ELSE            reduce using rule 59 (statement_var_dec -> lvalue1 var_list SEMICOLON .)


state 167

    (60) if -> IF LP exp . RP block elseif_blocks else_block
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    RP              shift and go to state 174
    ADDITION        shift and go to state 74
    SUBTRACTION     shift and go to state 75
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    LT              shift and go to state 84
    LE              shift and go to state 85
    GT              shift and go to state 86
    GE              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91


state 168

    (68) for -> FOR LP ID . IN exp TO exp STEPS exp RP block

    IN              shift and go to state 175


state 169

    (69) while -> WHILE LP exp . RP block
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    RP              shift and go to state 176
    ADDITION        shift and go to state 74
    SUBTRACTION     shift and go to state 75
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    LT              shift and go to state 84
    LE              shift and go to state 85
    GT              shift and go to state 86
    GE              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91


state 170

    (70) return -> RETURN exp SEMICOLON .

    RCB             reduce using rule 70 (return -> RETURN exp SEMICOLON .)
    VOID            reduce using rule 70 (return -> RETURN exp SEMICOLON .)
    STATIC          reduce using rule 70 (return -> RETURN exp SEMICOLON .)
    INT_TYPE        reduce using rule 70 (return -> RETURN exp SEMICOLON .)
    REAL_TYPE       reduce using rule 70 (return -> RETURN exp SEMICOLON .)
    BOOL_TYPE       reduce using rule 70 (return -> RETURN exp SEMICOLON .)
    STRING_TYPE     reduce using rule 70 (return -> RETURN exp SEMICOLON .)
    ID              reduce using rule 70 (return -> RETURN exp SEMICOLON .)
    SEMICOLON       reduce using rule 70 (return -> RETURN exp SEMICOLON .)
    INTEGER         reduce using rule 70 (return -> RETURN exp SEMICOLON .)
    REAL            reduce using rule 70 (return -> RETURN exp SEMICOLON .)
    TRUE            reduce using rule 70 (return -> RETURN exp SEMICOLON .)
    FALSE           reduce using rule 70 (return -> RETURN exp SEMICOLON .)
    STRING          reduce using rule 70 (return -> RETURN exp SEMICOLON .)
    LP              reduce using rule 70 (return -> RETURN exp SEMICOLON .)
    PRINT           reduce using rule 70 (return -> RETURN exp SEMICOLON .)
    IF              reduce using rule 70 (return -> RETURN exp SEMICOLON .)
    FOR             reduce using rule 70 (return -> RETURN exp SEMICOLON .)
    WHILE           reduce using rule 70 (return -> RETURN exp SEMICOLON .)
    RETURN          reduce using rule 70 (return -> RETURN exp SEMICOLON .)
    BREAK           reduce using rule 70 (return -> RETURN exp SEMICOLON .)
    CONTINUE        reduce using rule 70 (return -> RETURN exp SEMICOLON .)
    SUBTRACTION     reduce using rule 70 (return -> RETURN exp SEMICOLON .)
    NOT             reduce using rule 70 (return -> RETURN exp SEMICOLON .)
    BITWISE_NOT     reduce using rule 70 (return -> RETURN exp SEMICOLON .)
    ELSEIF          reduce using rule 70 (return -> RETURN exp SEMICOLON .)
    ELSE            reduce using rule 70 (return -> RETURN exp SEMICOLON .)


state 171

    (112) actual_arguments_list -> actual_arguments_list COMMA exp .
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    COMMA           reduce using rule 112 (actual_arguments_list -> actual_arguments_list COMMA exp .)
    RP              reduce using rule 112 (actual_arguments_list -> actual_arguments_list COMMA exp .)
    ADDITION        shift and go to state 74
    SUBTRACTION     shift and go to state 75
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    LT              shift and go to state 84
    LE              shift and go to state 85
    GT              shift and go to state 86
    GE              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91


state 172

    (52) assignment -> lvalue ASSIGNMENT exp SEMICOLON .

    RCB             reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)
    VOID            reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)
    STATIC          reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)
    INT_TYPE        reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)
    REAL_TYPE       reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)
    BOOL_TYPE       reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)
    STRING_TYPE     reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)
    ID              reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)
    SEMICOLON       reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)
    INTEGER         reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)
    REAL            reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)
    TRUE            reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)
    FALSE           reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)
    STRING          reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)
    LP              reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)
    PRINT           reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)
    IF              reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)
    FOR             reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)
    WHILE           reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)
    RETURN          reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)
    BREAK           reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)
    CONTINUE        reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)
    SUBTRACTION     reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)
    NOT             reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)
    BITWISE_NOT     reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)
    ELSEIF          reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)
    ELSE            reduce using rule 52 (assignment -> lvalue ASSIGNMENT exp SEMICOLON .)


state 173

    (57) print -> PRINT LP STRING RP . SEMICOLON

    SEMICOLON       shift and go to state 177


state 174

    (60) if -> IF LP exp RP . block elseif_blocks else_block
    (37) block -> . LCB statements_list RCB
    (38) block -> . statement
    (41) statement -> . SEMICOLON
    (42) statement -> . exp SEMICOLON
    (43) statement -> . assignment
    (44) statement -> . print
    (45) statement -> . statement_var_dec
    (46) statement -> . if
    (47) statement -> . for
    (48) statement -> . while
    (49) statement -> . return
    (50) statement -> . break
    (51) statement -> . continue
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (52) assignment -> . lvalue ASSIGNMENT exp SEMICOLON
    (57) print -> . PRINT LP STRING RP SEMICOLON
    (58) statement_var_dec -> . return_type var_list SEMICOLON
    (59) statement_var_dec -> . lvalue1 var_list SEMICOLON
    (60) if -> . IF LP exp RP block elseif_blocks else_block
    (68) for -> . FOR LP ID IN exp TO exp STEPS exp RP block
    (69) while -> . WHILE LP exp RP block
    (70) return -> . RETURN exp SEMICOLON
    (71) break -> . BREAK SEMICOLON
    (72) continue -> . CONTINUE SEMICOLON
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (18) return_type -> . INT_TYPE
    (19) return_type -> . REAL_TYPE
    (20) return_type -> . BOOL_TYPE
    (21) return_type -> . STRING_TYPE
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    LCB             shift and go to state 100
    SEMICOLON       shift and go to state 102
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    PRINT           shift and go to state 114
    IF              shift and go to state 117
    FOR             shift and go to state 118
    WHILE           shift and go to state 119
    RETURN          shift and go to state 120
    BREAK           shift and go to state 121
    CONTINUE        shift and go to state 122
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    INT_TYPE        shift and go to state 23
    REAL_TYPE       shift and go to state 24
    BOOL_TYPE       shift and go to state 25
    STRING_TYPE     shift and go to state 26
    ID              shift and go to state 49

    exp                            shift and go to state 103
    block                          shift and go to state 178
    statement                      shift and go to state 101
    assignment                     shift and go to state 104
    print                          shift and go to state 105
    statement_var_dec              shift and go to state 106
    if                             shift and go to state 107
    for                            shift and go to state 108
    while                          shift and go to state 109
    return                         shift and go to state 110
    break                          shift and go to state 111
    continue                       shift and go to state 112
    lvalue                         shift and go to state 113
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    return_type                    shift and go to state 115
    lvalue1                        shift and go to state 116
    lvalue2                        shift and go to state 65

state 175

    (68) for -> FOR LP ID IN . exp TO exp STEPS exp RP block
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 179
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 176

    (69) while -> WHILE LP exp RP . block
    (37) block -> . LCB statements_list RCB
    (38) block -> . statement
    (41) statement -> . SEMICOLON
    (42) statement -> . exp SEMICOLON
    (43) statement -> . assignment
    (44) statement -> . print
    (45) statement -> . statement_var_dec
    (46) statement -> . if
    (47) statement -> . for
    (48) statement -> . while
    (49) statement -> . return
    (50) statement -> . break
    (51) statement -> . continue
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (52) assignment -> . lvalue ASSIGNMENT exp SEMICOLON
    (57) print -> . PRINT LP STRING RP SEMICOLON
    (58) statement_var_dec -> . return_type var_list SEMICOLON
    (59) statement_var_dec -> . lvalue1 var_list SEMICOLON
    (60) if -> . IF LP exp RP block elseif_blocks else_block
    (68) for -> . FOR LP ID IN exp TO exp STEPS exp RP block
    (69) while -> . WHILE LP exp RP block
    (70) return -> . RETURN exp SEMICOLON
    (71) break -> . BREAK SEMICOLON
    (72) continue -> . CONTINUE SEMICOLON
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (18) return_type -> . INT_TYPE
    (19) return_type -> . REAL_TYPE
    (20) return_type -> . BOOL_TYPE
    (21) return_type -> . STRING_TYPE
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    LCB             shift and go to state 100
    SEMICOLON       shift and go to state 102
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    PRINT           shift and go to state 114
    IF              shift and go to state 117
    FOR             shift and go to state 118
    WHILE           shift and go to state 119
    RETURN          shift and go to state 120
    BREAK           shift and go to state 121
    CONTINUE        shift and go to state 122
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    INT_TYPE        shift and go to state 23
    REAL_TYPE       shift and go to state 24
    BOOL_TYPE       shift and go to state 25
    STRING_TYPE     shift and go to state 26
    ID              shift and go to state 49

    exp                            shift and go to state 103
    block                          shift and go to state 180
    statement                      shift and go to state 101
    assignment                     shift and go to state 104
    print                          shift and go to state 105
    statement_var_dec              shift and go to state 106
    if                             shift and go to state 107
    for                            shift and go to state 108
    while                          shift and go to state 109
    return                         shift and go to state 110
    break                          shift and go to state 111
    continue                       shift and go to state 112
    lvalue                         shift and go to state 113
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    return_type                    shift and go to state 115
    lvalue1                        shift and go to state 116
    lvalue2                        shift and go to state 65

state 177

    (57) print -> PRINT LP STRING RP SEMICOLON .

    RCB             reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)
    VOID            reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)
    STATIC          reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)
    INT_TYPE        reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)
    REAL_TYPE       reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)
    BOOL_TYPE       reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)
    STRING_TYPE     reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)
    ID              reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)
    SEMICOLON       reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)
    INTEGER         reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)
    REAL            reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)
    TRUE            reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)
    FALSE           reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)
    STRING          reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)
    LP              reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)
    PRINT           reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)
    IF              reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)
    FOR             reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)
    WHILE           reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)
    RETURN          reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)
    BREAK           reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)
    CONTINUE        reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)
    SUBTRACTION     reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)
    NOT             reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)
    BITWISE_NOT     reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)
    ELSEIF          reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)
    ELSE            reduce using rule 57 (print -> PRINT LP STRING RP SEMICOLON .)


state 178

    (60) if -> IF LP exp RP block . elseif_blocks else_block
    (61) elseif_blocks -> . elseifs
    (62) elseif_blocks -> .
    (63) elseifs -> . elseifs elseif
    (64) elseifs -> . elseif
    (65) elseif -> . ELSEIF LP exp RP block

  ! shift/reduce conflict for ELSEIF resolved as shift
    ELSE            reduce using rule 62 (elseif_blocks -> .)
    RCB             reduce using rule 62 (elseif_blocks -> .)
    VOID            reduce using rule 62 (elseif_blocks -> .)
    STATIC          reduce using rule 62 (elseif_blocks -> .)
    INT_TYPE        reduce using rule 62 (elseif_blocks -> .)
    REAL_TYPE       reduce using rule 62 (elseif_blocks -> .)
    BOOL_TYPE       reduce using rule 62 (elseif_blocks -> .)
    STRING_TYPE     reduce using rule 62 (elseif_blocks -> .)
    ID              reduce using rule 62 (elseif_blocks -> .)
    SEMICOLON       reduce using rule 62 (elseif_blocks -> .)
    INTEGER         reduce using rule 62 (elseif_blocks -> .)
    REAL            reduce using rule 62 (elseif_blocks -> .)
    TRUE            reduce using rule 62 (elseif_blocks -> .)
    FALSE           reduce using rule 62 (elseif_blocks -> .)
    STRING          reduce using rule 62 (elseif_blocks -> .)
    LP              reduce using rule 62 (elseif_blocks -> .)
    PRINT           reduce using rule 62 (elseif_blocks -> .)
    IF              reduce using rule 62 (elseif_blocks -> .)
    FOR             reduce using rule 62 (elseif_blocks -> .)
    WHILE           reduce using rule 62 (elseif_blocks -> .)
    RETURN          reduce using rule 62 (elseif_blocks -> .)
    BREAK           reduce using rule 62 (elseif_blocks -> .)
    CONTINUE        reduce using rule 62 (elseif_blocks -> .)
    SUBTRACTION     reduce using rule 62 (elseif_blocks -> .)
    NOT             reduce using rule 62 (elseif_blocks -> .)
    BITWISE_NOT     reduce using rule 62 (elseif_blocks -> .)
    ELSEIF          shift and go to state 184

  ! ELSEIF          [ reduce using rule 62 (elseif_blocks -> .) ]

    elseif_blocks                  shift and go to state 181
    elseifs                        shift and go to state 182
    elseif                         shift and go to state 183

state 179

    (68) for -> FOR LP ID IN exp . TO exp STEPS exp RP block
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    TO              shift and go to state 185
    ADDITION        shift and go to state 74
    SUBTRACTION     shift and go to state 75
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    LT              shift and go to state 84
    LE              shift and go to state 85
    GT              shift and go to state 86
    GE              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91


state 180

    (69) while -> WHILE LP exp RP block .

    RCB             reduce using rule 69 (while -> WHILE LP exp RP block .)
    VOID            reduce using rule 69 (while -> WHILE LP exp RP block .)
    STATIC          reduce using rule 69 (while -> WHILE LP exp RP block .)
    INT_TYPE        reduce using rule 69 (while -> WHILE LP exp RP block .)
    REAL_TYPE       reduce using rule 69 (while -> WHILE LP exp RP block .)
    BOOL_TYPE       reduce using rule 69 (while -> WHILE LP exp RP block .)
    STRING_TYPE     reduce using rule 69 (while -> WHILE LP exp RP block .)
    ID              reduce using rule 69 (while -> WHILE LP exp RP block .)
    SEMICOLON       reduce using rule 69 (while -> WHILE LP exp RP block .)
    INTEGER         reduce using rule 69 (while -> WHILE LP exp RP block .)
    REAL            reduce using rule 69 (while -> WHILE LP exp RP block .)
    TRUE            reduce using rule 69 (while -> WHILE LP exp RP block .)
    FALSE           reduce using rule 69 (while -> WHILE LP exp RP block .)
    STRING          reduce using rule 69 (while -> WHILE LP exp RP block .)
    LP              reduce using rule 69 (while -> WHILE LP exp RP block .)
    PRINT           reduce using rule 69 (while -> WHILE LP exp RP block .)
    IF              reduce using rule 69 (while -> WHILE LP exp RP block .)
    FOR             reduce using rule 69 (while -> WHILE LP exp RP block .)
    WHILE           reduce using rule 69 (while -> WHILE LP exp RP block .)
    RETURN          reduce using rule 69 (while -> WHILE LP exp RP block .)
    BREAK           reduce using rule 69 (while -> WHILE LP exp RP block .)
    CONTINUE        reduce using rule 69 (while -> WHILE LP exp RP block .)
    SUBTRACTION     reduce using rule 69 (while -> WHILE LP exp RP block .)
    NOT             reduce using rule 69 (while -> WHILE LP exp RP block .)
    BITWISE_NOT     reduce using rule 69 (while -> WHILE LP exp RP block .)
    ELSEIF          reduce using rule 69 (while -> WHILE LP exp RP block .)
    ELSE            reduce using rule 69 (while -> WHILE LP exp RP block .)


state 181

    (60) if -> IF LP exp RP block elseif_blocks . else_block
    (66) else_block -> . ELSE block
    (67) else_block -> .

    ELSE            shift and go to state 187
    ELSEIF          reduce using rule 67 (else_block -> .)
    RCB             reduce using rule 67 (else_block -> .)
    VOID            reduce using rule 67 (else_block -> .)
    STATIC          reduce using rule 67 (else_block -> .)
    INT_TYPE        reduce using rule 67 (else_block -> .)
    REAL_TYPE       reduce using rule 67 (else_block -> .)
    BOOL_TYPE       reduce using rule 67 (else_block -> .)
    STRING_TYPE     reduce using rule 67 (else_block -> .)
    ID              reduce using rule 67 (else_block -> .)
    SEMICOLON       reduce using rule 67 (else_block -> .)
    INTEGER         reduce using rule 67 (else_block -> .)
    REAL            reduce using rule 67 (else_block -> .)
    TRUE            reduce using rule 67 (else_block -> .)
    FALSE           reduce using rule 67 (else_block -> .)
    STRING          reduce using rule 67 (else_block -> .)
    LP              reduce using rule 67 (else_block -> .)
    PRINT           reduce using rule 67 (else_block -> .)
    IF              reduce using rule 67 (else_block -> .)
    FOR             reduce using rule 67 (else_block -> .)
    WHILE           reduce using rule 67 (else_block -> .)
    RETURN          reduce using rule 67 (else_block -> .)
    BREAK           reduce using rule 67 (else_block -> .)
    CONTINUE        reduce using rule 67 (else_block -> .)
    SUBTRACTION     reduce using rule 67 (else_block -> .)
    NOT             reduce using rule 67 (else_block -> .)
    BITWISE_NOT     reduce using rule 67 (else_block -> .)

  ! ELSE            [ reduce using rule 67 (else_block -> .) ]

    else_block                     shift and go to state 186

state 182

    (61) elseif_blocks -> elseifs .
    (63) elseifs -> elseifs . elseif
    (65) elseif -> . ELSEIF LP exp RP block

    ELSE            reduce using rule 61 (elseif_blocks -> elseifs .)
    RCB             reduce using rule 61 (elseif_blocks -> elseifs .)
    VOID            reduce using rule 61 (elseif_blocks -> elseifs .)
    STATIC          reduce using rule 61 (elseif_blocks -> elseifs .)
    INT_TYPE        reduce using rule 61 (elseif_blocks -> elseifs .)
    REAL_TYPE       reduce using rule 61 (elseif_blocks -> elseifs .)
    BOOL_TYPE       reduce using rule 61 (elseif_blocks -> elseifs .)
    STRING_TYPE     reduce using rule 61 (elseif_blocks -> elseifs .)
    ID              reduce using rule 61 (elseif_blocks -> elseifs .)
    SEMICOLON       reduce using rule 61 (elseif_blocks -> elseifs .)
    INTEGER         reduce using rule 61 (elseif_blocks -> elseifs .)
    REAL            reduce using rule 61 (elseif_blocks -> elseifs .)
    TRUE            reduce using rule 61 (elseif_blocks -> elseifs .)
    FALSE           reduce using rule 61 (elseif_blocks -> elseifs .)
    STRING          reduce using rule 61 (elseif_blocks -> elseifs .)
    LP              reduce using rule 61 (elseif_blocks -> elseifs .)
    PRINT           reduce using rule 61 (elseif_blocks -> elseifs .)
    IF              reduce using rule 61 (elseif_blocks -> elseifs .)
    FOR             reduce using rule 61 (elseif_blocks -> elseifs .)
    WHILE           reduce using rule 61 (elseif_blocks -> elseifs .)
    RETURN          reduce using rule 61 (elseif_blocks -> elseifs .)
    BREAK           reduce using rule 61 (elseif_blocks -> elseifs .)
    CONTINUE        reduce using rule 61 (elseif_blocks -> elseifs .)
    SUBTRACTION     reduce using rule 61 (elseif_blocks -> elseifs .)
    NOT             reduce using rule 61 (elseif_blocks -> elseifs .)
    BITWISE_NOT     reduce using rule 61 (elseif_blocks -> elseifs .)
    ELSEIF          shift and go to state 184

  ! ELSEIF          [ reduce using rule 61 (elseif_blocks -> elseifs .) ]

    elseif                         shift and go to state 188

state 183

    (64) elseifs -> elseif .

    ELSEIF          reduce using rule 64 (elseifs -> elseif .)
    ELSE            reduce using rule 64 (elseifs -> elseif .)
    RCB             reduce using rule 64 (elseifs -> elseif .)
    VOID            reduce using rule 64 (elseifs -> elseif .)
    STATIC          reduce using rule 64 (elseifs -> elseif .)
    INT_TYPE        reduce using rule 64 (elseifs -> elseif .)
    REAL_TYPE       reduce using rule 64 (elseifs -> elseif .)
    BOOL_TYPE       reduce using rule 64 (elseifs -> elseif .)
    STRING_TYPE     reduce using rule 64 (elseifs -> elseif .)
    ID              reduce using rule 64 (elseifs -> elseif .)
    SEMICOLON       reduce using rule 64 (elseifs -> elseif .)
    INTEGER         reduce using rule 64 (elseifs -> elseif .)
    REAL            reduce using rule 64 (elseifs -> elseif .)
    TRUE            reduce using rule 64 (elseifs -> elseif .)
    FALSE           reduce using rule 64 (elseifs -> elseif .)
    STRING          reduce using rule 64 (elseifs -> elseif .)
    LP              reduce using rule 64 (elseifs -> elseif .)
    PRINT           reduce using rule 64 (elseifs -> elseif .)
    IF              reduce using rule 64 (elseifs -> elseif .)
    FOR             reduce using rule 64 (elseifs -> elseif .)
    WHILE           reduce using rule 64 (elseifs -> elseif .)
    RETURN          reduce using rule 64 (elseifs -> elseif .)
    BREAK           reduce using rule 64 (elseifs -> elseif .)
    CONTINUE        reduce using rule 64 (elseifs -> elseif .)
    SUBTRACTION     reduce using rule 64 (elseifs -> elseif .)
    NOT             reduce using rule 64 (elseifs -> elseif .)
    BITWISE_NOT     reduce using rule 64 (elseifs -> elseif .)


state 184

    (65) elseif -> ELSEIF . LP exp RP block

    LP              shift and go to state 189


state 185

    (68) for -> FOR LP ID IN exp TO . exp STEPS exp RP block
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 190
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 186

    (60) if -> IF LP exp RP block elseif_blocks else_block .

    RCB             reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)
    VOID            reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)
    STATIC          reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)
    INT_TYPE        reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)
    REAL_TYPE       reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)
    BOOL_TYPE       reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)
    STRING_TYPE     reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)
    ID              reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)
    SEMICOLON       reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)
    INTEGER         reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)
    REAL            reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)
    TRUE            reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)
    FALSE           reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)
    STRING          reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)
    LP              reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)
    PRINT           reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)
    IF              reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)
    FOR             reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)
    WHILE           reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)
    RETURN          reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)
    BREAK           reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)
    CONTINUE        reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)
    SUBTRACTION     reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)
    NOT             reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)
    BITWISE_NOT     reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)
    ELSEIF          reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)
    ELSE            reduce using rule 60 (if -> IF LP exp RP block elseif_blocks else_block .)


state 187

    (66) else_block -> ELSE . block
    (37) block -> . LCB statements_list RCB
    (38) block -> . statement
    (41) statement -> . SEMICOLON
    (42) statement -> . exp SEMICOLON
    (43) statement -> . assignment
    (44) statement -> . print
    (45) statement -> . statement_var_dec
    (46) statement -> . if
    (47) statement -> . for
    (48) statement -> . while
    (49) statement -> . return
    (50) statement -> . break
    (51) statement -> . continue
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (52) assignment -> . lvalue ASSIGNMENT exp SEMICOLON
    (57) print -> . PRINT LP STRING RP SEMICOLON
    (58) statement_var_dec -> . return_type var_list SEMICOLON
    (59) statement_var_dec -> . lvalue1 var_list SEMICOLON
    (60) if -> . IF LP exp RP block elseif_blocks else_block
    (68) for -> . FOR LP ID IN exp TO exp STEPS exp RP block
    (69) while -> . WHILE LP exp RP block
    (70) return -> . RETURN exp SEMICOLON
    (71) break -> . BREAK SEMICOLON
    (72) continue -> . CONTINUE SEMICOLON
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (18) return_type -> . INT_TYPE
    (19) return_type -> . REAL_TYPE
    (20) return_type -> . BOOL_TYPE
    (21) return_type -> . STRING_TYPE
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    LCB             shift and go to state 100
    SEMICOLON       shift and go to state 102
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    PRINT           shift and go to state 114
    IF              shift and go to state 117
    FOR             shift and go to state 118
    WHILE           shift and go to state 119
    RETURN          shift and go to state 120
    BREAK           shift and go to state 121
    CONTINUE        shift and go to state 122
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    INT_TYPE        shift and go to state 23
    REAL_TYPE       shift and go to state 24
    BOOL_TYPE       shift and go to state 25
    STRING_TYPE     shift and go to state 26
    ID              shift and go to state 49

    block                          shift and go to state 191
    statement                      shift and go to state 101
    exp                            shift and go to state 103
    assignment                     shift and go to state 104
    print                          shift and go to state 105
    statement_var_dec              shift and go to state 106
    if                             shift and go to state 107
    for                            shift and go to state 108
    while                          shift and go to state 109
    return                         shift and go to state 110
    break                          shift and go to state 111
    continue                       shift and go to state 112
    lvalue                         shift and go to state 113
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    return_type                    shift and go to state 115
    lvalue1                        shift and go to state 116
    lvalue2                        shift and go to state 65

state 188

    (63) elseifs -> elseifs elseif .

    ELSEIF          reduce using rule 63 (elseifs -> elseifs elseif .)
    ELSE            reduce using rule 63 (elseifs -> elseifs elseif .)
    RCB             reduce using rule 63 (elseifs -> elseifs elseif .)
    VOID            reduce using rule 63 (elseifs -> elseifs elseif .)
    STATIC          reduce using rule 63 (elseifs -> elseifs elseif .)
    INT_TYPE        reduce using rule 63 (elseifs -> elseifs elseif .)
    REAL_TYPE       reduce using rule 63 (elseifs -> elseifs elseif .)
    BOOL_TYPE       reduce using rule 63 (elseifs -> elseifs elseif .)
    STRING_TYPE     reduce using rule 63 (elseifs -> elseifs elseif .)
    ID              reduce using rule 63 (elseifs -> elseifs elseif .)
    SEMICOLON       reduce using rule 63 (elseifs -> elseifs elseif .)
    INTEGER         reduce using rule 63 (elseifs -> elseifs elseif .)
    REAL            reduce using rule 63 (elseifs -> elseifs elseif .)
    TRUE            reduce using rule 63 (elseifs -> elseifs elseif .)
    FALSE           reduce using rule 63 (elseifs -> elseifs elseif .)
    STRING          reduce using rule 63 (elseifs -> elseifs elseif .)
    LP              reduce using rule 63 (elseifs -> elseifs elseif .)
    PRINT           reduce using rule 63 (elseifs -> elseifs elseif .)
    IF              reduce using rule 63 (elseifs -> elseifs elseif .)
    FOR             reduce using rule 63 (elseifs -> elseifs elseif .)
    WHILE           reduce using rule 63 (elseifs -> elseifs elseif .)
    RETURN          reduce using rule 63 (elseifs -> elseifs elseif .)
    BREAK           reduce using rule 63 (elseifs -> elseifs elseif .)
    CONTINUE        reduce using rule 63 (elseifs -> elseifs elseif .)
    SUBTRACTION     reduce using rule 63 (elseifs -> elseifs elseif .)
    NOT             reduce using rule 63 (elseifs -> elseifs elseif .)
    BITWISE_NOT     reduce using rule 63 (elseifs -> elseifs elseif .)


state 189

    (65) elseif -> ELSEIF LP . exp RP block
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 192
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 190

    (68) for -> FOR LP ID IN exp TO exp . STEPS exp RP block
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    STEPS           shift and go to state 193
    ADDITION        shift and go to state 74
    SUBTRACTION     shift and go to state 75
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    LT              shift and go to state 84
    LE              shift and go to state 85
    GT              shift and go to state 86
    GE              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91


state 191

    (66) else_block -> ELSE block .

    ELSEIF          reduce using rule 66 (else_block -> ELSE block .)
    ELSE            reduce using rule 66 (else_block -> ELSE block .)
    RCB             reduce using rule 66 (else_block -> ELSE block .)
    VOID            reduce using rule 66 (else_block -> ELSE block .)
    STATIC          reduce using rule 66 (else_block -> ELSE block .)
    INT_TYPE        reduce using rule 66 (else_block -> ELSE block .)
    REAL_TYPE       reduce using rule 66 (else_block -> ELSE block .)
    BOOL_TYPE       reduce using rule 66 (else_block -> ELSE block .)
    STRING_TYPE     reduce using rule 66 (else_block -> ELSE block .)
    ID              reduce using rule 66 (else_block -> ELSE block .)
    SEMICOLON       reduce using rule 66 (else_block -> ELSE block .)
    INTEGER         reduce using rule 66 (else_block -> ELSE block .)
    REAL            reduce using rule 66 (else_block -> ELSE block .)
    TRUE            reduce using rule 66 (else_block -> ELSE block .)
    FALSE           reduce using rule 66 (else_block -> ELSE block .)
    STRING          reduce using rule 66 (else_block -> ELSE block .)
    LP              reduce using rule 66 (else_block -> ELSE block .)
    PRINT           reduce using rule 66 (else_block -> ELSE block .)
    IF              reduce using rule 66 (else_block -> ELSE block .)
    FOR             reduce using rule 66 (else_block -> ELSE block .)
    WHILE           reduce using rule 66 (else_block -> ELSE block .)
    RETURN          reduce using rule 66 (else_block -> ELSE block .)
    BREAK           reduce using rule 66 (else_block -> ELSE block .)
    CONTINUE        reduce using rule 66 (else_block -> ELSE block .)
    SUBTRACTION     reduce using rule 66 (else_block -> ELSE block .)
    NOT             reduce using rule 66 (else_block -> ELSE block .)
    BITWISE_NOT     reduce using rule 66 (else_block -> ELSE block .)


state 192

    (65) elseif -> ELSEIF LP exp . RP block
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    RP              shift and go to state 194
    ADDITION        shift and go to state 74
    SUBTRACTION     shift and go to state 75
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    LT              shift and go to state 84
    LE              shift and go to state 85
    GT              shift and go to state 86
    GE              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91


state 193

    (68) for -> FOR LP ID IN exp TO exp STEPS . exp RP block
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    ID              shift and go to state 49

    exp                            shift and go to state 195
    lvalue                         shift and go to state 56
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    lvalue1                        shift and go to state 64
    lvalue2                        shift and go to state 65

state 194

    (65) elseif -> ELSEIF LP exp RP . block
    (37) block -> . LCB statements_list RCB
    (38) block -> . statement
    (41) statement -> . SEMICOLON
    (42) statement -> . exp SEMICOLON
    (43) statement -> . assignment
    (44) statement -> . print
    (45) statement -> . statement_var_dec
    (46) statement -> . if
    (47) statement -> . for
    (48) statement -> . while
    (49) statement -> . return
    (50) statement -> . break
    (51) statement -> . continue
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (52) assignment -> . lvalue ASSIGNMENT exp SEMICOLON
    (57) print -> . PRINT LP STRING RP SEMICOLON
    (58) statement_var_dec -> . return_type var_list SEMICOLON
    (59) statement_var_dec -> . lvalue1 var_list SEMICOLON
    (60) if -> . IF LP exp RP block elseif_blocks else_block
    (68) for -> . FOR LP ID IN exp TO exp STEPS exp RP block
    (69) while -> . WHILE LP exp RP block
    (70) return -> . RETURN exp SEMICOLON
    (71) break -> . BREAK SEMICOLON
    (72) continue -> . CONTINUE SEMICOLON
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (18) return_type -> . INT_TYPE
    (19) return_type -> . REAL_TYPE
    (20) return_type -> . BOOL_TYPE
    (21) return_type -> . STRING_TYPE
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    LCB             shift and go to state 100
    SEMICOLON       shift and go to state 102
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    PRINT           shift and go to state 114
    IF              shift and go to state 117
    FOR             shift and go to state 118
    WHILE           shift and go to state 119
    RETURN          shift and go to state 120
    BREAK           shift and go to state 121
    CONTINUE        shift and go to state 122
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    INT_TYPE        shift and go to state 23
    REAL_TYPE       shift and go to state 24
    BOOL_TYPE       shift and go to state 25
    STRING_TYPE     shift and go to state 26
    ID              shift and go to state 49

    exp                            shift and go to state 103
    block                          shift and go to state 196
    statement                      shift and go to state 101
    assignment                     shift and go to state 104
    print                          shift and go to state 105
    statement_var_dec              shift and go to state 106
    if                             shift and go to state 107
    for                            shift and go to state 108
    while                          shift and go to state 109
    return                         shift and go to state 110
    break                          shift and go to state 111
    continue                       shift and go to state 112
    lvalue                         shift and go to state 113
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    return_type                    shift and go to state 115
    lvalue1                        shift and go to state 116
    lvalue2                        shift and go to state 65

state 195

    (68) for -> FOR LP ID IN exp TO exp STEPS exp . RP block
    (86) binary_operation -> exp . ADDITION exp
    (87) binary_operation -> exp . SUBTRACTION exp
    (88) binary_operation -> exp . MULTIPLICATION exp
    (89) binary_operation -> exp . DIVISION exp
    (90) binary_operation -> exp . MODULO exp
    (91) binary_operation -> exp . POWER exp
    (92) binary_operation -> exp . SHIFT_LEFT exp
    (93) binary_operation -> exp . SHIFT_RIGHT exp
    (94) logical_operation -> exp . AND exp
    (95) logical_operation -> exp . OR exp
    (96) comparison_operation -> exp . LT exp
    (97) comparison_operation -> exp . LE exp
    (98) comparison_operation -> exp . GT exp
    (99) comparison_operation -> exp . GE exp
    (100) comparison_operation -> exp . EQ exp
    (101) comparison_operation -> exp . NE exp
    (102) bitwise_operation -> exp . BITWISE_AND exp
    (103) bitwise_operation -> exp . BITWISE_OR exp

    RP              shift and go to state 197
    ADDITION        shift and go to state 74
    SUBTRACTION     shift and go to state 75
    MULTIPLICATION  shift and go to state 76
    DIVISION        shift and go to state 77
    MODULO          shift and go to state 78
    POWER           shift and go to state 79
    SHIFT_LEFT      shift and go to state 80
    SHIFT_RIGHT     shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    LT              shift and go to state 84
    LE              shift and go to state 85
    GT              shift and go to state 86
    GE              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91


state 196

    (65) elseif -> ELSEIF LP exp RP block .

    ELSEIF          reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)
    ELSE            reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)
    RCB             reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)
    VOID            reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)
    STATIC          reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)
    INT_TYPE        reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)
    REAL_TYPE       reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)
    BOOL_TYPE       reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)
    STRING_TYPE     reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)
    ID              reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)
    SEMICOLON       reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)
    INTEGER         reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)
    REAL            reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)
    TRUE            reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)
    FALSE           reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)
    STRING          reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)
    LP              reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)
    PRINT           reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)
    IF              reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)
    FOR             reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)
    WHILE           reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)
    RETURN          reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)
    BREAK           reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)
    CONTINUE        reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)
    SUBTRACTION     reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)
    NOT             reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)
    BITWISE_NOT     reduce using rule 65 (elseif -> ELSEIF LP exp RP block .)


state 197

    (68) for -> FOR LP ID IN exp TO exp STEPS exp RP . block
    (37) block -> . LCB statements_list RCB
    (38) block -> . statement
    (41) statement -> . SEMICOLON
    (42) statement -> . exp SEMICOLON
    (43) statement -> . assignment
    (44) statement -> . print
    (45) statement -> . statement_var_dec
    (46) statement -> . if
    (47) statement -> . for
    (48) statement -> . while
    (49) statement -> . return
    (50) statement -> . break
    (51) statement -> . continue
    (73) exp -> . INTEGER
    (74) exp -> . REAL
    (75) exp -> . TRUE
    (76) exp -> . FALSE
    (77) exp -> . STRING
    (78) exp -> . lvalue
    (79) exp -> . binary_operation
    (80) exp -> . logical_operation
    (81) exp -> . comparison_operation
    (82) exp -> . bitwise_operation
    (83) exp -> . unary_operation
    (84) exp -> . LP exp RP
    (85) exp -> . function_call
    (52) assignment -> . lvalue ASSIGNMENT exp SEMICOLON
    (57) print -> . PRINT LP STRING RP SEMICOLON
    (58) statement_var_dec -> . return_type var_list SEMICOLON
    (59) statement_var_dec -> . lvalue1 var_list SEMICOLON
    (60) if -> . IF LP exp RP block elseif_blocks else_block
    (68) for -> . FOR LP ID IN exp TO exp STEPS exp RP block
    (69) while -> . WHILE LP exp RP block
    (70) return -> . RETURN exp SEMICOLON
    (71) break -> . BREAK SEMICOLON
    (72) continue -> . CONTINUE SEMICOLON
    (53) lvalue -> . lvalue1
    (54) lvalue -> . lvalue2
    (86) binary_operation -> . exp ADDITION exp
    (87) binary_operation -> . exp SUBTRACTION exp
    (88) binary_operation -> . exp MULTIPLICATION exp
    (89) binary_operation -> . exp DIVISION exp
    (90) binary_operation -> . exp MODULO exp
    (91) binary_operation -> . exp POWER exp
    (92) binary_operation -> . exp SHIFT_LEFT exp
    (93) binary_operation -> . exp SHIFT_RIGHT exp
    (94) logical_operation -> . exp AND exp
    (95) logical_operation -> . exp OR exp
    (96) comparison_operation -> . exp LT exp
    (97) comparison_operation -> . exp LE exp
    (98) comparison_operation -> . exp GT exp
    (99) comparison_operation -> . exp GE exp
    (100) comparison_operation -> . exp EQ exp
    (101) comparison_operation -> . exp NE exp
    (102) bitwise_operation -> . exp BITWISE_AND exp
    (103) bitwise_operation -> . exp BITWISE_OR exp
    (104) unary_operation -> . SUBTRACTION exp
    (105) unary_operation -> . NOT exp
    (106) unary_operation -> . BITWISE_NOT exp
    (107) function_call -> . lvalue2 function_call_body
    (108) function_call -> . lvalue1 function_call_body
    (18) return_type -> . INT_TYPE
    (19) return_type -> . REAL_TYPE
    (20) return_type -> . BOOL_TYPE
    (21) return_type -> . STRING_TYPE
    (56) lvalue1 -> . ID
    (55) lvalue2 -> . ID DOT ID

    LCB             shift and go to state 100
    SEMICOLON       shift and go to state 102
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    STRING          shift and go to state 55
    LP              shift and go to state 62
    PRINT           shift and go to state 114
    IF              shift and go to state 117
    FOR             shift and go to state 118
    WHILE           shift and go to state 119
    RETURN          shift and go to state 120
    BREAK           shift and go to state 121
    CONTINUE        shift and go to state 122
    SUBTRACTION     shift and go to state 66
    NOT             shift and go to state 67
    BITWISE_NOT     shift and go to state 68
    INT_TYPE        shift and go to state 23
    REAL_TYPE       shift and go to state 24
    BOOL_TYPE       shift and go to state 25
    STRING_TYPE     shift and go to state 26
    ID              shift and go to state 49

    exp                            shift and go to state 103
    block                          shift and go to state 198
    statement                      shift and go to state 101
    assignment                     shift and go to state 104
    print                          shift and go to state 105
    statement_var_dec              shift and go to state 106
    if                             shift and go to state 107
    for                            shift and go to state 108
    while                          shift and go to state 109
    return                         shift and go to state 110
    break                          shift and go to state 111
    continue                       shift and go to state 112
    lvalue                         shift and go to state 113
    binary_operation               shift and go to state 57
    logical_operation              shift and go to state 58
    comparison_operation           shift and go to state 59
    bitwise_operation              shift and go to state 60
    unary_operation                shift and go to state 61
    function_call                  shift and go to state 63
    return_type                    shift and go to state 115
    lvalue1                        shift and go to state 116
    lvalue2                        shift and go to state 65

state 198

    (68) for -> FOR LP ID IN exp TO exp STEPS exp RP block .

    RCB             reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)
    VOID            reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)
    STATIC          reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)
    INT_TYPE        reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)
    REAL_TYPE       reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)
    BOOL_TYPE       reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)
    STRING_TYPE     reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)
    ID              reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)
    SEMICOLON       reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)
    INTEGER         reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)
    REAL            reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)
    TRUE            reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)
    FALSE           reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)
    STRING          reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)
    LP              reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)
    PRINT           reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)
    IF              reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)
    FOR             reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)
    WHILE           reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)
    RETURN          reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)
    BREAK           reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)
    CONTINUE        reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)
    SUBTRACTION     reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)
    NOT             reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)
    BITWISE_NOT     reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)
    ELSEIF          reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)
    ELSE            reduce using rule 68 (for -> FOR LP ID IN exp TO exp STEPS exp RP block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSEIF in state 178 resolved as shift
